<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>IOU</title><meta name=viewport content="width=device-width"><link rel=icon type=image/x-icon href=favicon.ico><link rel=stylesheet href=/css/main.a636.css></head><body><div class=docs><div class=container><header class=slide><ul id=navToggle class="burger slide"><li></li><li></li><li></li></ul><h1><a href="/"><i class="fa fa-home"></i></a></h1></header><nav class=slide><ul><li><a href=/docs class=menu-title>IOU Docs</a></li><li><a href=/chapter/chapter-1.html>Chapter 1</a></li><li><a href=/chapter/chapter-2.html>Chapter 2</a></li><li><a href=/chapter/chapter-3.html>Chapter 3</a></li><li><a href=/chapter/chapter-4.html>Chapter 4</a></li><li><a href=/chapter/chapter-5.html>Chapter 5</a></li><li><a href=/chapter/chapter-6.html>Chapter 6</a></li><li><a href=/chapter/chapter-7.html>Chapter 7</a></li><li><a href=/chapter/chapter-8.html>Chapter 8</a></li><li><a href=/chapter/chapter-9.html>Chapter 9</a></li><li><a href=/chapter/chapter-10.html>Chapter 10</a></li><li><a href=/chapter/chapter-11.html>Chapter 11</a></li><li><a href=/chapter/chapter-12.html>Chapter 12</a></li><li><a href=/pdf/index.pdf>Download PDF <i class="fa fa-download"></i></a></li></ul></nav><div class="content slide"><div class=body-section><div class=padded><h1>Chapter 3</h1><h2>Research and Development Method</h2><p>Chapter two described the problem domain, this chapter explains the rationale behind the technological decisions taken in order to achieve the best results in the implementation of IOU.</p><h3>The functional requirements</h3><p>IOU is mostly an online application, user data gets saved in the server and devices being used to access the data should be ubiquitous, that is, accessible from both a native mobile application or from a web application running on a browser.</p><p>The application should only allow login and registration via Facebook and the presence of WebSockets is a big plus, so that users do not need to refresh their views in order to see the most up-to-date information, much like a chat room.</p><p>Users should be able to create an unlimited amount of lists, on which they can add both members and products. Each list will also have a name and an icon associated to them. Both of which are editable. A list can only be viewed, edited or closed by their members.</p><p>Once a product is added to a list, it should be treated as an item that is still due to be bought. Any user from any given list can &#39;buy&#39; those products. Adding or editing the price and name of any product, both bought and due to be bought products, can be done at any time. There should be a timestamp for each bought product stating the last time it was edited, in addition, any bought product that has been edited should be flagged as edited.</p><p>Every list should also have a members view, where more members can be added and it should clearly state the breakdown of how much each member owes or is owed in relation to the user currently logged in.</p><p>The main list view should display the current user overall balance, that is, taking into account all lists he/she belongs to. Within the single list views, the overall balance presented should be constrained to the current list.</p><p>The Login page, Terms and conditions of usage an Privacy Policy pages should be open to public access, however, all other pages should be private.</p><p>Only users that accepted the Terms and conditions of usage can register and login.</p><p>A left navigation menu should be present on all private pages, showing the picture and name of who is logged in as well as links to the home view, the terms and conditions view, the privacy policy view and a logout.</p><p>Upon logout, all local storage data should be cleared, the user should be logged out from the application and redirect to the login page.</p><p>A go home button should be present on all screens to aid navigation.</p><p>The main action of each page should be presented in a block button in the bottom of each page.</p><h3>The backend technology choices</h3><p>There is no doubt that to achieve it, data should be provided by means of a Web Service Restful API, where the endpoints expose data in a convenient JSON format to be consumed by either a native mobile application or from a web application running on a browser. However, the options on how to implement such structure are endless. Below is a list of some of the available choices highlighting their benefits and constraints:</p><ul><li><p>PHP backend using Laravel (Otwell, 2015):</p><ul><li>Pros: This would&#39;ve been the easiest solution, Laravel is a very flexible framework that provides powerful and yet simple to use features. It&#39;s routing system could easily cater for the necessities of IOU, queues are easy to integrate and packages such as socialite can take care of the Facebook authentication.</li><li>Cons: Although there is a possibility to use other databases, MySQL is still the predominant option within the PHP world. WebSockets are rather difficult to integrate. Even though HHVM can compile PHP code to C, it still lacks the extra speed boost necessary for a real time apps.</li></ul></li><li><p>Node.js (Nodejs.org, 2015):</p><ul><li>Pros: Works really well with noSQL databases and WebSockets. Frameworks like Sails make it really easy to create and expose a Restful API and it performs quite well in terms of speed.</li><li>Cons: Not as easy as with PHP to find a suitable free server to start the work.</li></ul></li><li><p>Firebase (Firebase.com, 2015):</p><ul><li>Pros: No need to write an API, store your data on Firebase, set up your security rules and you are ready to go. Full support for WebSockets and social media integration, such as Facebook. Fast speed from noSQL databases and the entry plan is free of charge.</li><li>Cons: If you want to process anything other than data, such as images and payment, you will still need a backend system other than Firebase. As your application expands in number of users, plans become more expensive.</li></ul></li></ul><h3>The frontend technology choices</h3><p>For the frontend app, the choices were more limited, that is, in order to run a native application on a phone, one must develop constrained to the architecture he/she is writing if for. For example, Java is the native environment for Android apps and iOS developers have a choice between Swift and Objective-C (Developer.apple.com, 2015).</p><p>Another option was to create a hybrid phone application, that is, write it using common web application technologies such as HTML, CSS and JavaScript, then compile it using either PhoneGap or Apache Cordova to run inside the target architectures web view. As a side note, PhoneGap (Phonegap.com, 2015) is a branch from the open source project Apache Cordova (Cordova.apache.org, 2015) administered by Adobe.</p><p>The last option was to use Titanium AppCelerator (Appcelerator, 2015), which sits somewhere in between a native and a hybrid application, Titanium exposes a JavaScript API and converts them to the native function calls to the target architecture on compiling time.</p><p>Despite having to choose which frontend technology is best suited for IOU, one more element had to be considered. That is, the addition of a framework that would allow faster development and provide amenities such as high level abstractions for the platform and testing facilities. This is specially important, since the app has to run on more than one platform, including web.</p><p>At this point, the idea of using either a native application solution or Titanium, were beginning to fade, native apps would be constrained to one architecture only and therefore, have to be re-developed for every other platform. Titanium, solves that problem, but constraints the developer to a rather cryptic API that does not look like JavaScript.</p><p>That&#39;s when I came across Ionic (Ionicframework.com, 2015), Ionic is a frontend SDK for developing hybrid mobile apps. Frameworks such as Lungo and Topcoat, do cover part of what Ionic does, that is, they provide consistent widgets that can be used interchangeably throughout different platforms. However, Ionic goes the extra mile, not only providing frontend widgets, but also exposing an API that wraps Apache Cordova and a tight integration with Angular.js, making it the ultimate production tool when the subject comes to developing hybrid phone applications.</p><h3>The decisions</h3><p>The final choice was to stick to Ionic for the frontend and Firebase for the backend.</p><p>The main rationale behind this decision was how both technologies combine and complement each other. Firebase provides a driver that integrates with Angular.js (Angularjs.org, 2015), converting it into a true 3-way data binding tool.</p><p>Angular.js is a tool backed up by Google which aims to structure JavaScript apps and impulse the development of applications that otherwise would be impossible to develop or to the very least take too long.</p><p>Besides, Angular&#39;s Eco System boasts a vibrant community. Integration with Node.js workflow tools such as Yeoman (Yeoman.io, 2015), Bower (Bower.io, 2015) and Grunt (Gruntjs.com, 2014) are a breeze, E2E and Unit testing tools options are vast and Directives truly extend the vocabulary of HTML.</p><p>It still falls short in a sense that the application is not native, that is, some of the transition effects may not be as smooth as those provided natively and despite Firebase being a really interesting backend solution, in future, if the app needs to consume more powerful features, such as image resize and integration or a payment gateway, although in their pipeline for future development, Firebase will not yet suffice.</p><p>Nevertheless, the combination of those tools have been proven to be right for IOU, future improvements will dictate what other technologies will be used.</p><p>The diagram below represents the communication between the clients and the server. Every request that goes to Firebase must first satisfy the security rules. The double arrows represent the WebSockets:</p><p><img src=../img/sockets.b169.png alt=Fig2> <em>Fig 2 - WebSockets architecture</em></p><h3>The newer technologies</h3><p>After the technologies that were used in this project were decided, two notable alternatives arisen, although not necessarily a better option, exploring the following will be essential in future implementation decisions:</p><ul><li><p>React.js (Facebook.github.io, 2015): This is a library created and maintained by Facebook, as opposed to Angular.js, which uses HTML as its&#39; templating language, React relies on a virtual DOM, that is, an abstraction of the DOM is created within JavaScript, allowing the app to to update the views in real time, without the necessity of triggering an expensive digest loop. This in turn seems to resolve the issue some of the Ionic apps suffer from in terms of slow DOM updates that make the app look and feel sluggish.</p></li><li><p>Monaca (Monaca.io, 2015): This is a paid framework, that has a limited features version available free of charge. Much like Ionic, Monaca uses Angular.js to power the application and seems to have a very similar set of features as Ionic, nevertheless, it integrates Crosswalk in all Android apps by default. Crosswalk is the latest Chromium version, that when compiled along side a hybrid mobile application, renders animations more gracefully than the default Android Web View. Of course, Ionic apps can be packaged with Crosswalk, but it does not come free from some configuration overhead.</p></li></ul><h2>The workflow</h2><p>Now that the technologies have been chosen, an efficient workflow must be devised in order to maximise production and generate good quality builds. Below is a non exhaustive list of the technologies used for this application:</p><ul><li>Git<ul><li>Git-Flow</li></ul></li><li>Node.js<ul><li>Cordova</li><li>Yeoman</li><li>generator-ionic</li><li>Bower</li><li>Angular</li><li>Angular Animate</li><li>Angular Local Storage</li><li>Angular UI Router</li><li>Firebase</li><li>Angularfire</li><li>Ionic</li><li>Firebase</li><li>ngCordova</li><li>Grunt</li><li>autoprefixer</li><li>contrib-compass</li><li>contrib-concat</li><li>contrib-cssmin</li><li>contrib-htmlmin</li><li>contrib-jshint</li><li>contrib-uglify</li><li>contrib-watch</li><li>ng-annotate</li><li>ng-constant</li><li>usemin</li><li>wiredep</li><li>stylish</li></ul></li><li>Ruby Gems<ul><li>SASS</li><li>Compass</li></ul></li><li>Android SDK</li><li>iOS SDK</li></ul><p>In addition, the Cordova in-app-browser plugin has also been installed for both Android and iOS platforms in order to aid Facebook oAuth login with Firebase within a pop-up window.</p><h3>Git and Git-Flow</h3><p>Git (Git-scm.com, 2015) has been the version control system of choice for this assignment. Git, originally created by Linus Torvalds (YouTube, 2015), despite being relatively new, is now a mature tool that as opposed to more conservative VCSs&#39; takes a distributed approach. Without getting in too much detail, what it really means is that branches are &#39;cheap&#39; to create, there is no need to deploy every branch to the remote repository, every developer keeps the relevant branches to himself in his local repository. Nevertheless, in practice, it is a good idea to have one central repository to keep track of the projects&#39; progress. For this assignment, GitHub (GitHub, 2015) has been chosen as the origin.</p><p>In addition, in order to keep a reasonable workflow, this assignment adheres to git flow guidelines (Atlassian Git Tutorial, 2015). Originally a blog post by Vincent Driessen (nvie.com, 2012):</p><p><img src=../img/gitflow.9898.png alt=Fig3> <em>Fig 3 - Git-flow workflow</em></p><p>Although not directly relevant for this project, as it has been developed by only one person, Git-flow provides a mean to keep the repository organised ensuring different developers can collaborate in different points of a project lifecycle. Should this project ever expand into a bigger application, new developers will be able to collaborate immediately, without too much overhead. The main selling point for implementing Git-flow, is this instance, was so that commits happen in appropriate branches and that Releases and Hotfixes are tagged appropriately. To ensure that the branching model follows the workflow correctly, Vincent has written a Git plugin that facilitates adherence to his proposed model. It can be found in the repository below (GitHub, 2015):</p><p><a href=https://github.com/nvie/gitflow>https://github.com/nvie/gitflow</a></p><p>This project uses the above plugin and adheres to Vincets&#39; model.</p><h3>Node.js</h3><p>Despite being originally a backend tool, it&#39;s powerful package manager (Npmjs.com, 2015), has now been proven to be an excellent tool to manage any JavaScript project, being it a backend, frontend or hybrid application. Since this assignment relies on Firebase as the backend technology, Node.js has been used to manage the frontend assets.</p><p>In a nutshell, three tools were used:</p><ul><li><p>Yeoman: Used to scaffold the app, Yeoman is an scaffolding tool, created and maintained by Google, whereby developers can share their workflow with others. The generator used for this application was created by Diego Netto (GitHub, 2015), his generator is recommended by the creators of Ionic, the framework of choice for this assignment.</p></li><li><p>Bower: Bower is being used to manage the frontend CSS and JavaScript assets. It takes care of all dependencies allowing the Git repository to be slimmer, since the dependencies do not need to make part of it. Furthermore, this project uses Wiredep (Stephenplusplus.github.io, 2015), a Grunt task that triggers every time a new bower dependency is added. And automatically injects the dependency within Usemin blocks (GitHub, 2015). Of course, there is a chance this process may fail, since not all bower dependencies are developed in a way that Wiredep understands, however, as a rule of thumb, all bower dependencies must be added using the --save flag, for example:</p><p>$ bower install bootstrap --save</p><ul><li>Since we used the save flag, our bower.json should now contain a new entry, in this case &#39;bootstrap&#39; and &#39;jQuery&#39; (Bootstraps&#39; dependency), and since bower.json has changed, our watcher must have triggered Wiredep, which in turn must have added the dependencies to our index.html. This brings us to the second rule of thumb, one must always check that Wiredep has added the dependency appropriately in the HTML file.</li></ul></li><li><p>Grunt: Grunt is used as the overall manager for all the tasks running. Several watchers are running simultaneous and a complex build process is happening involving concatenating, obfuscating and minifying code. All this adds up to less HTTP requests for the final application and a more &#39;machine ready&#39; production code. In order to keep up with a good coding style, a JSLint (Crockford, 2015) task has also been incorporated and runs every time a JavaScript file is modified, it runs a series of strict checks and outputs its&#39; results within the Grunt-CLI. The heuristic behind JSLint is to always declare a ‘use strict’ statement at the top of every JavaScript file, this ensures that the most strict set of rules will be applied for all checks. The diagram below represents the building process, whereby the left side is the Git repository that contains the application code and the right side is a replaceable built result:</p></li></ul><p><img src=../img/build.115f.png alt=Fig4> <em>Fig 4 - Build Process</em></p><p>The code is then optimised:</p><p><img src=../img/optimisation.dafe.png alt=Fig5> <em>Fig 5 - Optimisation Process</em></p><p>And finally compiled to the target mobile platforms:</p><p><img src=../img/compilation.0bdc.png alt=Fig6> <em>Fig 6 - Compilation Process</em></p><h3>Angular js</h3><p>Developed and maintained by Google, Angular adds several advantages to the development process of JavaScript applications. The four main points to mention are:</p><ul><li><p>Two way data binding: Angular has models that bind to the view via a $scope. Every time a model changes its value, the view is updated. This reflects into shorter code that does not rely on DOM structure and manipulation. Freeing the developer to concentrate in the applications&#39; logic rather than its&#39; formatting.</p></li><li><p>Directives: When DOM manipulation is absolutely necessary, Angular provides directives, whereby developers can write reusable pieces of code that operate in a set of data in combination with the DOM structure. Throughout this application, a reusable directive has been used to cater for the search feature.</p></li><li><p>Structure: Angular adds structure to an application. Although commonly following an MVC architecture, Angular calls itself an MVW framework, which literally stands for Mode-View-Whatever, it lays out the guidelines, but leaves it up to the developer on how to best implement them. All applications typically have an entry point, called the run method; Templates can be decorated with directives and expressions, further DOM manipulation can be encapsulated within reusable Directives; Shared functionality can be created as services, which in turn can be configured during different points of the applications&#39; lifecycle; Code behind view blocks can be stored in controllers; application state can be managed via routes, filters provide formatting and filtering functionality; And it can all be grouped within modules, which are very similar to namespaces, other than modules will also declare their external dependencies and provide the methods to implement all the above (Panda, 2014).</p></li><li><p>Dependency Injection: As mentioned by Brian Ford in a Google developer conference (YouTube, 2015), dependency injection can be defined with one sentence: &quot;Don&#39;t call me, I&#39;ll call you&quot;. What he means is that it is a design pattern that implements inversion of control, one of the SOLID principles (Butunclebob.com, 2015). Instead of instantiating objects within our methods, we simply declare the dependencies in our methods&#39; signature, Angular will recognise the services a module depends on and will automatically inject the correct instantiated objects when that method is called during run time. This makes the methods more testable and more decoupled from one another, hence, immediately providing higher adherence to SOLID principles.</p></li></ul><p>In addition, this application makes use of an Angular service called Angular Local Storage, this dependency provides a simple API to interact with HTML5 local storage for different clients. It will also fall back to cookies, should Local Storage not be available in the current system (Pike, 2015).</p><h3>Ionic and Cordova</h3><p>In the core of this entire application is Ionic, a Framework for building hybrid (native/web) applications for smart devices (phones/tablets). Finding and deciding on using Ionic was the single most laborious research for this project.</p><p>Prototypes were written using different frameworks, most of those frameworks would either only have a set of UI interfaces, such as Topcoat (Topcoat.io, 2015) or lack a polished structure, such as the Lungo-Angular-Bridge (GitHub, 2014). Nonetheless, Ionic that provided all the necessary tools and workflow to accomplish the final task in one framework.</p><p>Being backed by Drifty Co. (Drifty, 2015) a company that works closely with Google, and having their CEO, Max Lynch, writing the Angular.js port for Material Design (YouTube, 2015), places Ionic in a very respectable position.</p><p>Despite all that, Ionic created and makes use of ngCordova (IonicFramework, 2015) a tool that seamlessly integrates Angular.js with Apache Cordova, making it easy to call the low level Cordova API without compromising on the application architecture.</p><p>It also provides a beautiful set of predefined UI elements and Directives that package them together for advance usage. Plus, Angular-UI-Router (Angular-ui.github.io, 2015) is already packaged in the bundle, so nested routes and states can also be implemented.</p><p>In addition, Ionic keeps an up-to-date forum and documentation, not to mention a nightly built code sample library on Code-Pen (Codepen.io, 2015).</p><p>Ionic has also recently released a service called Ionic View (Apps.ionic.io, 2015), which allows developers to view and share their application on different mobile platforms without going through the hassle of deploying their app in any app store. And will soon release a push notification system (Apps.ionic.io, 2015), now closing the loop with all necessary services to develop complex hybrid mobile applications.</p><h3>Firebase</h3><p>Combining noSQL with a layer of WebSockets (Pusher.com, 2015), comes Firebase, it is not only a database system in the cloud but also a full eco system that caters for security annotations on top of your data structure and oAuth integration with third party providers such as Facebook and Google+. This project integrates Firebase by means of a library called Angularfire (Firebase.com, 2015). Angularfire is a library written by the Firebase team that aids easier integration with Angular, converting the application into a Three way data binding tool, when data changes in the database the view for all clients is immediately updated, real-time. Combining a top notch support team and being now part of Google, I am confident Firebase will soon become one of the biggest entities for backend solutions.</p><p>Chapter 7 develops further the obstacles imposed by Firebase, noSQL (Mongodb.com, 2015) in general and the techniques employed to overcome those limitations.</p><h3>SASS/Compass</h3><p>This projects makes use of CSS pre-processors in order to simplify the stylesheets necessary to render the application. A Grunt task (GitHub, 2015) then aids it further, by means of running the Compass (Compass-style.org, 2015) watch task necessary to transform the SASS (Sass-lang.com, 2015) code into CSS. It also makes use of another task called Autoprefixer (GitHub, 2015), which in turn prefixes CSS3 declarations with the browser vendors annotations. For example, as a developer, I may wish to use border radius for my buttons, my CSS class may look like the following:</p><div class=highlight><pre><code class=language-text data-lang=text>.btn {
  border-radius: 5px;
}
</code></pre></div><p>After running Autoprefixer, the browser vendors will be added like so:</p><div class=highlight><pre><code class=language-text data-lang=text>.btn {
  -webkit-border-radius: 5px;
     -moz-border-radius: 5px;
          border-radius: 5px;
}
</code></pre></div><p>This process runs automatically whenever a SASS file is changed throughout the application, providing, of course, that the Grunt serve tasks is running.</p><p>In addition, Compass, provides a full library of Mixins, aiding further with common CSS patterns. In the SASS world, CSS development is seen much like Object Oriented Development, that is, a class can be extended, variables can be created and even nesting is allowed. Mixins are simply a piece of reusable CSS, that can be mixed into any other CSS class.</p><h3>The SDKs&#39;</h3><p>Firstly, in order to develop an iOS application, one must be developing on a Macintosh computer, this is necessary since the SDKs&#39; come bundled with XCode (Developer.apple.com, 2015) a Mac specific application. Providing that, the set up for iOS is rather simplistic, one only needs to download and install XCode, accept the terms and conditions and ensure the command line tools are installed and available.</p><p>In the other hand, the Android SDK (Android SDK, 2015) can be proven to be slightly more difficult to install and configure. The first dependency to be installed is the Java JDK (Oracle.com, 2015), almost all the other dependencies can be met by means of installing the Android Studio, an excellent IDE built on top of the JetBrains IntelliJ. However, if you wish to develop in the terminal there are a few other things that must be made available on your path:</p><ul><li>Ant</li><li>The SDK platform-tools</li><li>The JAVA_HOME variable</li><li>ADB (The Android Debug Bridge)</li></ul><p>With all that in place, Android development should be possible, however, if that seems like too much overhead, Ionic offers a Vagrant (Vagrantup.com, 2015) box already preconfigured to develop Ionic apps for Android, it can be obtained from the link below:</p><p><a href=https://github.com/driftyco/ionic-box>https://github.com/driftyco/ionic-box</a></p><p>Vagrant is a Virtual Machines manager that integrates with Oracles Virtual Box (Virtualbox.org, 2015). Both tools are available free of charge. Furthermore, it allows port forwarding and directories mapping with the local development system. The Vagrant box above, therefore allows Android development without the need to install and configure an Android environment.</p></div></div></div></div></div><script src=/js/scripts.1ec7.js></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-62901832-1', 'auto');
            ga('send', 'pageview');</script></body></html>