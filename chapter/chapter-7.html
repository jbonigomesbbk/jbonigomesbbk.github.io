<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>IOU</title><meta name=viewport content="width=device-width"><link rel=icon type=image/x-icon href=favicon.ico><link rel=stylesheet href=/css/main.9795.css></head><body><div class=docs><div class=container><header class=slide><ul id=navToggle class="burger slide"><li></li><li></li><li></li></ul><h1><a href="/"><i class="fa fa-home"></i></a></h1></header><nav class=slide><ul><li><a href=/docs class=menu-title>IOU Docs</a></li><li><a href=/chapter/chapter-1.html>Chapter 1</a></li><li><a href=/chapter/chapter-2.html>Chapter 2</a></li><li><a href=/chapter/chapter-3.html>Chapter 3</a></li><li><a href=/chapter/chapter-4.html>Chapter 4</a></li><li><a href=/chapter/chapter-5.html>Chapter 5</a></li><li><a href=/chapter/chapter-6.html>Chapter 6</a></li><li><a href=/chapter/chapter-7.html>Chapter 7</a></li><li><a href=/chapter/chapter-8.html>Chapter 8</a></li><li><a href=/chapter/chapter-9.html>Chapter 9</a></li><li><a href=/chapter/chapter-10.html>Chapter 10</a></li><li><a href=/chapter/chapter-11.html>Chapter 11</a></li><li><a href=/pdf/index.pdf>Download PDF <i class="fa fa-download"></i></a></li></ul></nav><div class="content slide"><div class=body-section><div class=padded><h1>Chapter 7</h1><h2>Review/Reflections</h2><h3>Data architecture</h3><p>Coming from a relational databases background, one of the most difficult mind set to adapt, was to start thinking in a noSQL way.</p><p>In noSQL, data is stored as key value pairs, that in turn, can hold nested key value pairs, in practice, data is represented as a JSON notation object that can be queried by traversing the tree structure.</p><p>The IOU app is powered by, Firebase, an implementation of a noSQL database, that although very fast and scalable comes with a few limitations, for example, it only allows a depth of up to 32 levels when nesting data objects and although data can be queried as arrays, it does not support storing data as arrays, all values must be strictly stored as JSON key value pairs.</p><p>From the Firebase documentation, the inital data structure was organised as the sample JSON object below:</p><p>https://www.firebase.com/docs/web/guide/structuring-data.html</p><div class=highlight><pre><code class=language-text data-lang=text>{
  &quot;lists&quot;: {
    &quot;123&quot;: {
      &quot;name&quot;: &quot;Households&quot;,
      &quot;image&quot;: &quot;lightbuld&quot;,

      &quot;members&quot;: {
        &quot;444&quot; : true,
        &quot;555&quot; : true
      }

      &quot;products&quot;: {
        &quot;567&quot; : true,
        &quot;891&quot; : true
      }
    },

    &quot;234&quot;: { ... },

    &quot;345&quot;: { ... }
  },

  &quot;products&quot;: {
    &quot;567&quot; : {
      &quot;amended&quot; : true,
      &quot;date&quot;    : 1412635438623,
      &quot;name&quot;    : &quot;Potatoes&quot;,
      &quot;owner&quot;   : &quot;444&quot;,
      &quot;price&quot;   : &quot;28&quot;
      &quot;bought&quot;  : true
    },

    &quot;891&quot; : { ... }
  }

  &quot;members&quot;: {
    &quot;444&quot;: {
      &quot;name&quot; : &quot;Jose Gomes&quot; 
    },

    &quot;555&quot;: { ... }
  },
}
</code></pre></div><p>In contrast with a more traditional relational data structure, there is not much going on in the sample above. There are three main collections (lists, products and members) and each hold a series of entries, represented by a unique key which in turn holds the values for that row. The only extraneous notation is how the relations are declared, instead of foreign keys, Firebase recommends setting relations like so:</p><div class=highlight><pre><code class=language-text data-lang=text>&quot;members&quot;: {
  &quot;444&quot; : true,
  &quot;555&quot; : true
}
</code></pre></div><p>This may look intriguing at first, however, since Firebase does not support arrays in their storage, this is the nearest achieavable way to represent a one-to-many relation.</p><p>Although easy to understand, this initial set up does not make use of the full potential from a noSQL database, within a key value architecture, the developer is not constrained to the limitations of data normalisation, the database can be molded in whichever way it best suits the application using it. Besides, joins considerably deteriorate the performance of your database.</p><p>The following blog post by Anant Narayanan, was the first stage in denormalising the inital concept:</p><p>https://www.firebase.com/blog/2013-04-12-denormalizing-is-normal.html</p><p>In addition, in conversation with Sara Robinson, Developer Evangelist at Firebase, during the a Google Developers Conference, it became clearer that a more nested structure would boost the application performance yet making it easier to perform queries that return meaningfull data.</p><p>As a result, the second iteration architecturaly looks like the following:</p><div class=highlight><pre><code class=language-text data-lang=text>{
  &quot;lists&quot; : {
    &quot;123&quot; : {
      &quot;name&quot;  : &quot;Households&quot;,
      &quot;image&quot; : &quot;lightbulb&quot;,

      &quot;bought&quot; : {
        &quot;567&quot; : {
          &quot;amended&quot; : true,
          &quot;date&quot;    : 1412635438623,
          &quot;name&quot;    : &quot;Potatoes&quot;,
          &quot;owner&quot;   : &quot;444&quot;,
          &quot;price&quot;   : &quot;28&quot;
        },
        &quot;891&quot; : { ... }
      },

      &quot;tobuy&quot; : {
        &quot;678&quot; : {
          &quot;date&quot; : 1412635438623,
          &quot;name&quot; : &quot;Steak&quot;
        },
        &quot;789&quot; : { ... }
      },

      &quot;members&quot;: {
        &quot;444&quot; : true,
        &quot;555&quot; : true
      }
    },

    &quot;234&quot; : { ... },

    &quot;345&quot; : { ... }
  },

  &quot;members&quot; : {
    &quot;444&quot; : {
      &quot;name&quot; : &quot;Jose Gomes&quot;
    },

    &quot;555&quot; : { ... }
  }
}
</code></pre></div><p>Since the IOU app differenciates products that have been bought from products that are still due to be bought, the first step taken was to break down products into two categories (bought and tobuy). This, in turn, raised the awarness that both structures did not have the same attributes. Secondly, since a set of products belong to a list only, much like a one-to-many relationship, it was only natural to nest those two new objects within a list object, those two actions not only improved the speed to which data can be read, but also represent, if not, describe, the IOU app architecture.</p><p>Finally, during the last iteration and after coming to a realisation of how Firebase security rules work, it was decided that a collection of members was not nescessary. This decision was made for two reasons, firstly, simply to make the structure cleaner, thus completely avoid joins and secondly because the objects are too simple, the only data stored is their Facebook id and their names. Besides, if a username is stored in the database, should the user update his/her name on Facebook, IOU will never be notified and will therefore always display an out-of-date username. The final data structure simply removes the members object completely:</p><div class=highlight><pre><code class=language-text data-lang=text>{
  &quot;lists&quot; : {
    &quot;123&quot; : {
      &quot;name&quot;  : &quot;Households&quot;,
      &quot;image&quot; : &quot;lightbulb&quot;,

      &quot;bought&quot; : {
        &quot;567&quot; : {
          &quot;amended&quot; : true,
          &quot;date&quot;    : 1412635438623,
          &quot;name&quot;    : &quot;Potatoes&quot;,
          &quot;owner&quot;   : &quot;444&quot;,
          &quot;price&quot;   : &quot;28&quot;
        },
        &quot;891&quot; : { ... }
      },

      &quot;tobuy&quot; : {
        &quot;678&quot; : {
          &quot;date&quot; : 1412635438623,
          &quot;name&quot; : &quot;Steak&quot;
        },
        &quot;789&quot; : { ... }
      },

      &quot;members&quot;: {
        &quot;444&quot; : true,
        &quot;555&quot; : true
      }
    },

    &quot;234&quot; : { ... },

    &quot;345&quot; : { ... }
  },
}
</code></pre></div><p>This final decision raises one last problem, now every time a use is displayed, an AJAX call must be made to Facebooks&#39; Graph API in order to return a users&#39; username. Although simplistic, this approach generates a non-obvious problem, when retrieving a list of users of unknown length, we have to wait for all Asynchronous calls to be finished before rendering the list.</p><p>Before going on details, it is important to clarify what a promise is. In Angular.js, most Asynchronous calls are treated as promises, this concept is not new, as mentioned in Wikipedia, the term promise was proposed in 1976 by Daniel P. Friedman and David Wise, and Peter Hibbard called it eventual. However, in the JavaScript world, it&#39;s implementation is still taking &#39;baby steps&#39;. In Angular.js, when a function is meant to return the result of an asynchronous call, an AJAX call for example, this call will be said to return a promise that will be resolved some time in the future. For example, one may wish to stipulate what should be done in the event of an error, or bind the data returned to a model in the event of a succesful call.</p><p>Fortunately, Angular provides a service callded $q, this service is packed with methods that aid promises handling. This project uses a method of $q called all(). The all() method receives two arguments, the first is an array of promises and the second is a callback function that will be executed when all the promises in the array are resolved, in addition, the data returned by each promise will be packed as an array and passed as an argument to this function. Taking this approach resolved the problem imposed when rendering a list of users, the code sample below has been used the the users:</p><div class=highlight><pre><code class=language-text data-lang=text>// userswithnames refers to an array of promises
// created making sucessive AJAX calls to Facebooks&#39;
// Graph API, based in the stored user ids&#39;
$q.all(userswithnames).then(function(members) {
  // bind each member to the view
});
</code></pre></div><p>In addition, to minimise the number of AJAX calls, since the member that is currently logged in will have his/her data presented throught most states of the application, during login time IOU will store the users information on Local Storage, hence minimising the usage of $q only to render the members list view.</p><h3>$digest loop</h3><p>talk about async calls and the angular $digest loop</p><h3>oAuth</h3><p>Despite simplifying the entire oAuth process with third parties, Firebase still requires some configuration in order to work as expected.</p><p>Since IOU uses Facebook authentication, the first step is to create a Facebook developer account, then generate a new Facebook app. This process will create an unique Facebook app ID and a secret key. Those two parameters must then be configured accordingly inside Firebases&#39; admin panel.</p><p>The next step is to choose an appropriate firebase oAuth method, there are several options, however, IOU is constrained to use the authWithOAuthPopup method, since it is the supported both on all major web browsers and within Cordovas&#39; In-App-Broweser extension.</p><p>The final step is ensure sufficient information about the users is collected from Facebook during the login process. this is done via a scope variable, IOU collects the basic public user information, such as the users email address, profile picture and full name, in addition, IOU will also ask permission to have access to the users friends list.</p><p>It is important to note that although IOU has access to the users friends list, Facebook will only return the list of Friends of a user that also happen to be an IOU users. This limitation exist to avoid abuses such as spamming, but can, however be quite confusing for a first time Facebook app developer.</p><p>Once all this is in place, Firebase will take care of all the rest, such as token management and providing a consistent API for loging users in and out of the application as well as providing basic information about users and authentication status.</p><h3>Security rules</h3><p>Firebase provides a set of annotations that follow the data structure of the application. In addition to authentication, those annotations dictate who has access to read and write specific sets of data.</p><p>It is important to note that the security rules are not part of the application code, those anotations are set up in the server via Firebases&#39; admin tool and are therefore not visible even to those who have access to the application source code.</p><p>Once a user is logged in, Firebase will assign a variable named auth, which is by default set to null, to an object containing the logged user information. Rules can then be written to ensure that a given user does not have access to data he/she has no access to.</p><p>Much like the Firebase structure, those rules are written in a JSON format and follow the same structure of the Firebase data. For example, in order to control access of a list, so that only users that belong to a list can view and edit it, the following rule may be used:</p><div class=highlight><pre><code class=language-text data-lang=text>{
  &quot;rules&quot;: {
    &quot;.read&quot;: false,
    &quot;.write&quot;: false,
    &quot;lists&quot;: {
      &quot;$list&quot; {
        &quot;.read&quot;  : &quot;(root.child(&#39;members/&#39; + auth.uid).val() === auth.uid)&quot;,
        &quot;.write&quot; : &quot;(root.child(&#39;members/&#39; + auth.uid).val() === auth.uid)&quot;,
      }
    }
  }
}
</code></pre></div><p>In order to test security rules, Firebase provides a tool in their admin interface which simulates data reads and writes.</p><p>When developing more complex rules, Firebase has created a tool called Blaze, which compiles yaml formatted data into workable security rules and allows usage of reusable variables and functions.</p><h3>Play and App stores</h3><p>Updating on Android store must have the key and the password, using the key, run the jarsigner tool then zipalign</p><p>Last but not least, as opposed to web applications, apps published in the Google Play Store and Apple App Store, must be digitaly signed. Each platform operates in a different way, however the principle is the same, the developer generates a key that is used to sign the first version of the application. Subsequent updates to the same will have to be signed with the same key.</p><p>Apple makes this process easier within Xcode, the generated key is automatically added to the developers keychain and the signing process is carried out seamlesly within Xcode.</p><p>Android has a slightly more complicated process, whereby three steps are nescessary when creating the first version of an app:</p><ul><li><p>Firstly, a key must be generated, replacing &#39;my-release-key&#39; with the desired key name and &#39;alias_name&#39; with the desired alias name:</p><p>$ keytool -genkey -v -keystore my-release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000</p></li><li><p>This command will produce a key, and it is the developers&#39; responsibility to keep it safe for future updates, the key generation process will ask several questions about the developers identity and will ask for a password to be created in the end of the process.</p></li><li><p>The next step involves signing the unsigned app with the newly generated key:</p><p>$ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore HelloWorld-release-unsigned.apk alias_name</p></li><li><p>Finally, the apk that will be uploaded to the Play Store can now be generated:</p><p>$ zipalign -v 4 HelloWorld-release-unsigned.apk HelloWorld.apk</p></li></ul><p>It is worth mentioning that the first step should only be executed once, subsequent updades will then reused the key for the jarsigner before it can be zipaligned. Failure to provide the same key will block the app from being updated.</p></div></div></div></div></div><script src=/js/scripts.1ec7.js></script></body></html>