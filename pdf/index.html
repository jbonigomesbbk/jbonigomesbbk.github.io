<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>IOU</title><meta name=viewport content="width=device-width"><link rel=stylesheet href=../css/print.css></head><body><div class=breakpage><h1>Chapter 1</h1><h2>Introduction</h2><p>The idea for IOU came up from a need raised long before the current technology allowed its&#39; existence.</p><p>Being a student living in London for over a decade, almost by definition, meant that I had to share my house expenses with other housemates. This is not constrained to myself and my housemates, most of my friends also share their houses or flats. In fact this problem is not even constrained to a students, most young citizens also find it much easier to share their houses, easing down not only their expenses, but also making friends and having due company in the process.</p><p>IOU is a simple application, that allows users to share and track their expenses with their Facebook friends, in fact, IOU has been designed so that one is not constrained to only use it for such purposes, one may wish to use it in order to track his own expenses, or who owes who in the last Barbecue party or even a family using it to know what groceries to buy.</p><p>The concept aims to be as simple as it can get, users create or are added to lists of products, each user can only view and edit lists that he/she belongs to. Each list has two sublists, a list of users and a list of products. The list of products is then subdivided into two lists, products that are due to be bought and products that have been already bought.</p><p>The sum of all products bought in a list, divided by the number of users, is the ideal amount each list member should had spent, however, in practice a member will rarely be in this situation, IOU will then label members as either a debtor or a creditor, if one is a debtor, he/she should be aware that is his/her turn to buy the next round of products.</p><p>A list lifecycle can last as long as it&#39;s members find suitable, when it is time to close the list, they may review how much each members owe each other, exchange money (which happens without any interference of IOU), then close the list.</p><p>For example, a list of expenses between two long term friends may never be closed and a list between housemates may be closed once one or more of the housemates decides to live somewhere else.</p><p>By no means IOU guarantees that the members who overspent money in a list will get paid back, it assumes that users have a &quot;Gentlemen&#39;s&quot; agreement among each other and should simply be used to track who&#39;s turn to buy products is and somewhat act as a reminder as to what should be bought.</p><p>At any given time, a user can open any given list and view who owes him/her and who he/she owes money to. This number should be optimised in terms of change, to avoid hassle in terms of money exchange, that is, if one is a creditor in a list, he/she should never need to pay anyone back, likewise, if one is a debtor, he/she should only pay back creditors their given percentage. This in turn should avoid users paying someone who will then use part of the received money to pay someone else.</p><p>To make this all work, IOU is distributed as a mobile phone application and enforces users to login using their Facebook profiles. What makes IOU possible now is the fact that most of the population nowadays happen to own a Facebook account as well as a smartphone with access to the internet. This makes the application very convenient, enabling users to easily find their Friends and check what needs to be bought on the go.</p><h2>Notes about this documentation</h2><p>Code blocks appear as the following Scheme hello world example:</p><div class=highlight><pre><code class=language-text data-lang=text>(define hello-world
    (lambda ()
          (begin
         (write ‘Hello-World)
             (newline)
         (hello-world))))
</code></pre></div><p>Code meant to be run in the terminal will be prefixed with a dollar &#39;$&#39; sign, please note that the &#39;$&#39; should not be typed in, as the following Grunt initialise function demonstrates:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt init
</code></pre></div><p>Figures and captions are displayed like so:</p><p><img src=../img/sockets.b169.png alt=Fig1> <em>Fig 1 - WebSockets architecture</em></p></div><div class=breakpage><h1>Chapter 2</h1><h2>Literature review and Context</h2><p>Although a good idea, IOU is not alone, in fact, there are several other smartphone applications that allow expense sharing and beyond.</p><p>This chapter aims to rationalise each of the main alternatives in contrast with IOU, highlighting where it exceeds and where it falls short.</p><p>The list of IOU phone apps comparison in this chapter is by no means exhaustive, neither in number of features nor in the number of applications. It simply names the most popular applications available and analyses their main features.</p><h3>Splitwise</h3><h4>What is it</h4><p>A fully featured money splitting application that allows users to track expenses and even caters for fairness common bill sharing problems such as, to which extent is a girlfriend a housemate and how rent should be split.</p><h4>Where it falls short</h4><p>Although it integrates with Google+, it has no integration with Facebook, making it a little harder to find your friends and rather difficult to use in different devices, having to remember which email address and password was used when one first signed up for a service seems slightly out of fashion now.</p><p>For some, this may be a plus, but I find it has too many features, making it complicated to get started with, for example, when creating an item, the user has to stipulate how to split it, debts simplification is an option and it does not enforce the usage of groups.</p><p>It only tracks what users have spent, not what is due to be bought.</p><h4>Where it exceeds</h4><p>Other than the points made above, it is really hard to find something wrong with this application, it is available for all major platforms, including a web version, it is very complete, boasts a beautiful interface and is never wrong when the subject comes to maths accuracy. Most of all, it is free.</p><p>If I were to choose an application other than IOU, Splitwise would be my first choice.</p><h3>I.O.U - I Owe You</h3><h4>What is it</h4><p>It is a simple application to keep track of IOU notes.</p><h4>Where it falls short</h4><p>It is only available for Android users and the interface is not particularly pleasant to look at. It does not integrate with social media of any kind, operating more as a stand alone application.</p><h4>Where it exceeds</h4><p>Simplicity, it does what it says in the tin, tracks IOU notes.</p><h3>Still Waiting</h3><h4>What is it</h4><p>Yet another IOU reminder application.</p><h4>Where it falls short</h4><p>It does not integrate with Facebook and the app is not consistent through different platforms, the iOS version being much more superior both in terms of features and interface. The iOS version is not free of charge. Much like &#39;I.O.U - I Owe You&#39;, it is constrained to track IOU notes and not having a &#39;due to buy queue&#39;.</p><h4>Where it exceeds</h4><p>It has a pleasant interface and a pragmatic approach towards grouping bills based on people. Has a good set of options and even allows adding pictures and geolocation to your bills.</p><h3>IOU - by INEBAS</h3><h4>What is it</h4><p>An application for tracking expenses, bills and IOU notes.</p><h4>Where it falls short</h4><p>It is only available in the iOS App Store and is not free of charge.</p><h4>Where it exceeds</h4><p>It has a beautiful and pleasant to use interface. Tracks lending and borrowing money.</p><h2>Conclusion</h2><p>In short, if one is looking for an IOU application, the options are endless, but what sets me into still want to create yet another IOU application is the fact that although all applications mentioned above (even those not mentioned), may do their job quite well, they fall short in the most fundamental issue, they do not solve my problem.</p><h3>The problem</h3><p>All applications tested and tried during the research time for IOU are consistently ignoring the workflow of the user and simply focusing on a more general approach to bill sharing, if they were to narrow their scope to a smaller niche, then they would be able to appeal better to that given group.</p><p>Some did narrowed their focus, however, constantly towards restaurant bills sharing.</p><p>The main feature that sets IOU apart, is that fact that it allows users to set a desire to buy something, for example:</p><ul><li>If I am throwing a party, I may set up items to be bought, on a list, as my friends buy them, they mark the items as bought along with how much they spent.</li><li>If I finish the milk at home, I may add it to my housemates list, perhaps another housemate will notice it when strolling around the supermarket before going home.</li></ul><p>IOU is not only a maths tool, but also, a communication mechanism that seamlessly integrates in the users day-to-day activities.</p><h3>How does IOU approach it</h3><p>The way I envision IOU usage is by being an app that is checked every time one goes to the supermarket or remembers something to be bought for the weekend party or drinks the last bit of milk from the fridge. Once it becomes a habit to use it, you no longer need to make groceries lists or ask anyone what is missing for the party or for the house in general.</p><p>In addition, IOU&#39;s data-feed happens in real time, being always connected via a WebSocket, this means users do not need to trigger a page refresh. When the data changes, the screen updates automatically.</p><p>Finally, having Facebook integration, allows users to simply refer to IOU as an extension of an application they are already using. Making the eco system simple and familiar.</p><h3>Some aid literature</h3><ul><li><p>AngularJs from Novice to Ninja, by Sandeep Panda, is the single book that has helped me the most getting started in the world of Angular.js, explaining in a simple and effective way the various components that compose the eco-system.</p></li><li><p>Mastering Web Application Development with AngularJS, by Pawel Kozlowski and Peter Bacon Darwin proposes a by feature approach to structuring Angular.js apps, this is gradually becoming the de facto structure for most Angular.js applications.</p></li><li><p>Hackers and Painters, by Paul Graham, although not directly related to the work done towards IOU, when feeling overwhelmed by a technology or exhausted to the point of giving up, reading about Paul&#39;s experiences at ViaWeb uplifted my motivation and placed me back in the right track.</p></li><li><p>Both the Ionic and the Firebase blog have been essential in this journey too.</p></li></ul></div><div class=breakpage><h1>Chapter 3</h1><h2>Research and Development Method</h2><p>Chapter two described the problem domain, this chapter explains the rationale behind the technological decisions taken in order to achieve the best results in the implementation of IOU.</p><h3>The functional requirements</h3><p>IOU is mostly an online application, user data gets saved in the server and devices being used to access the data should be ubiquitous, that is, accessible from both a native mobile application or from a web application running on a browser.</p><p>The application should only allow login and registration via Facebook and the presence of WebSockets is a big plus, so that users do not need to refresh their views in order to see the most up-to-date information, much like a chat room.</p><p>Users should be able to create an unlimited amount of lists, on which they can add both members and products. Each list will also have a name and an icon associated to them. Both of which are editable. A list can only be viewed, edited or closed by their members.</p><p>Once a product is added to a list, it should be treated as an item that is still due to be bought. Any user from any given list can &#39;buy&#39; those products. Adding or editing the price and name of any product, both bought and due to be bought products, can be done at any time. There should be a timestamp for each bought product stating the last time it was edited, in addition, any bought product that has been edited should be flagged as edited.</p><p>Every list should also have a members view, where more members can be added and it should clearly state the breakdown of how much each member owes or is owed in relation to the user currently logged in.</p><p>The main list view should display the current user overall balance, that is, taking into account all lists he/she belongs to. Within the single list views, the overall balance presented should be constrained to the current list.</p><p>The Login page, Terms and conditions of usage an Privacy Policy pages should be open to public access, however, all other pages should be private.</p><p>Only users that accepted the Terms and conditions of usage can register and login.</p><p>A left navigation menu should be present on all private pages, showing the picture and name of who is logged in as well as links to the home view, the terms and conditions view, the privacy policy view and a logout.</p><p>Upon logout, all local storage data should be cleared, the user should be logged out from the application and redirect to the login page.</p><p>A go home button should be present on all screens to aid navigation.</p><p>The main action of each page should be presented in a block button in the bottom of each page.</p><h3>The backend technology choices</h3><p>There is no doubt that to achieve it, data should be provided by means of a Web Service Restful API, where the endpoints expose data in a convenient JSON format to be consumed by either a native mobile application or from a web application running on a browser. However, the options on how to implement such structure are endless. Below is a list of some of the available choices highlighting their benefits and constraints:</p><ul><li><p>PHP backend using Laravel:</p><ul><li>Pros: This would&#39;ve been the easiest solution, Laravel is a very flexible framework that provides powerful and yet simple to use features. It&#39;s routing system could easily cater for the necessities of IOU, queues are easy to integrate and packages such as socialite can take care of the Facebook authentication.</li><li>Cons: Although there is a possibility to use other databases, MySQL is still the predominant option within the PHP world. WebSockets are rather difficult to integrate. Even though HHVM can compile PHP code to C, it still lacks the extra speed boost necessary for a real time apps.</li></ul></li><li><p>Node.js:</p><ul><li>Pros: Works really well with noSQL databases and WebSockets. Frameworks like Sails make it really easy to create and expose a Restful API and it performs quite well in terms of speed.</li><li>Cons: Not as easy as with PHP to find a suitable free server to start the work.</li></ul></li><li><p>Firebase:</p><ul><li>Pros: No need to write an API, store your data on Firebase, set up your security rules and you are ready to go. Full support for WebSockets and social media integration, such as Facebook. Fast speed from noSQL databases and the entry plan is free of charge.</li><li>Cons: If you want to process anything other than data, such as images and payment, you will still need a backend system other than Firebase. As your application expands in number of users, plans become more expensive.</li></ul></li></ul><h3>The frontend technology choices</h3><p>For the frontend app, the choices were more limited, that is, in order to run a native application on a phone, one must develop constrained to the architecture he/she is writing if for. For example, Java is the native environment for Android apps and iOS developers have a choice between Swift and Objective-C.</p><p>Another option was to create a hybrid phone application, that is, write it using common web application technologies such as HTML, CSS and JavaScript, then compile it using either PhoneGap or Apache Cordova to run inside the target architectures web view. As a side note, PhoneGap is a branch from the open source project Apache Cordova administered by Adobe.</p><p>The last option was to use Titanium AppCelerator, which sits somewhere in between a native and a hybrid application, Titanium exposes a JavaScript API and converts them to the native function calls to the target architecture on compiling time.</p><p>Despite having to choose which frontend technology is best suited for IOU, one more element had to be considered. That is, the addition of a framework that would allow faster development and provide amenities such as high level abstractions for the platform and testing facilities. This is specially important, since the app has to run on more than one platform, including web.</p><p>At this point, the idea of using either a native application solution or Titanium, were beginning to fade, native apps would be constrained to one architecture only and therefore, have to be re-developed for every other platform. Titanium, solves that problem, but constraints the developer to a rather cryptic API that does not look like JavaScript.</p><p>That&#39;s when I came across Ionic, Ionic is a frontend SDK for developing hybrid mobile apps. Frameworks such as Lungo and Topcoat, do cover part of what Ionic does, that is, they provide consistent widgets that can be used interchangeably throughout different platforms. However, Ionic goes the extra mile, not only providing frontend widgets, but also exposing an API that wraps Apache Cordova and a tight integration with Angular.js, making it the ultimate production tool when the subject comes to developing hybrid phone applications.</p><h3>The decisions</h3><p>The final choice was to stick to Ionic for the frontend and Firebase for the backend.</p><p>The main rationale behind this decision was how both technologies combine and complement each other. Firebase provides a driver that integrates with Angular.js, converting it into a true 3-way data binding tool.</p><p>Angular.js is a tool backed up by Google which aims to structure JavaScript apps and impulse the development of applications that otherwise would be impossible to develop or to the very least take too long.</p><p>Besides, Angular&#39;s Eco System boasts a vibrant community. Integration with Node.js workflow tools such as Yeoman, Bower and Grunt are a breeze, E2E and Unit testing tools options are vast and Directives truly extend the vocabulary of HTML.</p><p>It still falls short in a sense that the application is not native, that is, some of the transition effects may not be as smooth as those provided natively and despite Firebase being a really interesting backend solution, in future, if the app needs to consume more powerful features, such as image resize and integration with a payment gateways, although in their pipeline for future development, Firebase will not yet suffice.</p><p>Nevertheless, the combination of those tools have been proven to be right for IOU, future improvements will dictate what other technologies will be used.</p><p>The diagram below represents the communication between the clients and the server. Every request that goes to Firebase must first satisfy the security rules. The double arrows represent the WebSockets:</p><p><img src=../img/sockets.b169.png alt=Fig2> <em>Fig 2 - WebSockets architecture</em></p><h3>The newer technologies</h3><p>After the technologies that were used in this project were decided, two notable alternatives arisen, although not necessarily a better option, exploring the following will be essential in future implementation decisions:</p><ul><li><p>React.js: This is a library created and maintained by Facebook, as opposed to Angular.js, which uses HTML as its&#39; templating language, React relies on a virtual DOM, that is, an abstraction of the DOM is created within JavaScript, allowing the app to to update the views in real time, without the necessity of triggering an expensive digest loop. This in turn seems to resolve the issue some of the Ionic apps suffer from in terms of slow DOM updates that make the app look and feel sluggish.</p></li><li><p>Monaca: This is a paid framework, that has a limited features version available free of charge. Much like Ionic, Monaca uses Angular.js to power the application API and seems to have a very similar set features as Ionic, the only plus side being that it integrates Crosswalk in all apps by default. Crosswalk is the latest Chromium version, that when compiled along side a hybrid mobile application, renders animations much more gracefully than the default Android Web View. Of course, Ionic apps can also be packaged with Crosswalk, but it does not come free of some configuration overhead.</p></li></ul><h2>The workflow</h2><p>Now that the technologies have been chosen, an efficient workflow must be devised in order to maximize production and generate good quality builds. Below is a non exhaustive list of the technologies used for this application:</p><ul><li>Git<ul><li>Git-Flow</li></ul></li><li>Node.js<ul><li>Cordova</li><li>Yeoman</li><li>generator-ionic</li><li>Bower</li><li>Angular</li><li>Angular Animate</li><li>Angular Local Storage</li><li>Angular UI Router</li><li>Firebase</li><li>Angularfire</li><li>Ionic</li><li>Firebase</li><li>ngCordova</li><li>Grunt</li><li>autoprefixer</li><li>contrib-compass</li><li>contrib-concat</li><li>contrib-cssmin</li><li>contrib-htmlmin</li><li>contrib-jshint</li><li>contrib-uglify</li><li>contrib-watch</li><li>ng-annotate</li><li>ng-constant</li><li>usemin</li><li>wiredep</li><li>stylish</li></ul></li><li>Ruby Gems<ul><li>SASS</li><li>Compass</li></ul></li><li>Android SDK</li><li>iOS SDK</li></ul><p>In addition, the Cordova in-app-browser plugin has also been installed for both Android and iOS platforms in order to aid Facebook oAuth login with Firebase within a pop-up window.</p><h3>Git and Git-Flow</h3><p>Git has been the version control system of choice for this assignment. Git, originally created by Linus Torvalds, despite being relatively new, is now a mature tool that as opposed to more conservative VCSs&#39; takes a distributed approach. Without getting in too much detail, what it really means is that branches are &#39;cheap&#39; to create, there is no need to deploy every branch to the remote repository, every developer keeps the relevant branches to himself in his local repository. Nevertheless, in practice, it is a good idea to have one central repository to keep track of the projects&#39; progress. For this assignment, GitHub has been chosen as the origin.</p><p>In addition, in order to keep a reasonable workflow, this assignment adheres to git flow guidelines. Originally a blog post by Vincent Driessen:</p><p><img src=../img/gitflow.9898.png alt=Fig3> <em>Fig 3 - Git-flow workflow</em></p><p>Although not directly relevant for this project, as it has been developed by only one person, Git-flow provides a mean to keep the repository organised ensuring different developers can collaborate in different points of a project lifecycle. Should this project ever expand into a bigger application, new developers will be able to collaborate immediately, without too much overhead. The main selling point for implementing Git-flow, is this instance, was so that commits happen in appropriate branches and that Releases and Hotfixes are tagged appropriately. To ensure that the branching model follows the workflow correctly, Vincent has written a Git plugin that facilitates adherence to his proposed model. It can be found in the repository below:</p><p><a href=https://github.com/nvie/gitflow>https://github.com/nvie/gitflow</a></p><p>This project uses the above plugin and adheres to Vincets&#39; model.</p><h3>Node.js</h3><p>Despite being originally a backend tool, it&#39;s powerful package manager (NPM), has now been proven to be an excellent tool to manage any JavaScript project, being it a backend, frontend or hybrid application. Since this assignment relies on Firebase as the backend technology, Node.js has been used to manage the frontend assets.</p><p>In a nutshell, three tools were used:</p><ul><li><p>Yeoman: Used to scaffold the app, Yeoman is an scaffolding tool, created and maintained by Google, whereby developers can share their workflow with others. The generator used for this application was created by Diego Netto, his generator is recommended by the creators of Ionic, the framework of choice for this assignment.</p></li><li><p>Bower: Bower: Bower is being used to manage the frontend CSS and JavaScript assets. It takes care of all dependencies allowing the Git repository to be slimmer, since the dependencies do not need to make part of it. Furthermore, this project uses Wiredep, a Grunt task that triggers every time a new bower dependency is added. And automatically injects the dependency within Usemin blocks. Of course, there is a chance this process may fail, since not all bower dependencies are developed in a way that Wiredep understands, however, as a rule of thumb, all bower dependencies must be added using the --save flag, for example:</p><p>$ bower install bootstrap --save</p><ul><li>Since we used the save flag, our bower.json should now contain a new entry, in this case &#39;bootstrap&#39; and &#39;jQuery&#39; (Bootstraps&#39; dependency), and since bower.json has changed, our watcher must have triggered Wiredep, which in turn must have added the dependencies to our index.html. This brings us to the second rule of thumb, one must always check that Wiredep has added the dependency appropriately in the HTML file.</li></ul></li><li><p>Grunt: Grunt is used as the overall manager for all the tasks running. Several watchers are running simultaneous and a complex build process is happening involving concatenating, obfuscating and minifying code. All this adds up to less HTTP requests for the final application and a more &#39;machine ready&#39; production code. In order to keep up with a good coding style, a JSLint task has also been incorporated and runs every time a JavaScript file is modified, it runs a series of strict checks and outputs its&#39; results within the Grunt-CLI. The heuristic behind JSLint is to always declare a ‘use strict’ statement at the top of every JavaScript file, this ensures that the most strict set of rules will be applied for all checks. The diagram below represents the building process, whereby the left side is the Git repository that contains the application code and the right side is a replaceable built result:</p></li></ul><p><img src=../img/build.115f.png alt=Fig4> <em>Fig 4 - Build Process</em></p><p>The code is then optimised:</p><p><img src=../img/optimisation.dafe.png alt=Fig5> <em>Fig 5 - Optimisation Process</em></p><p>And finally compiled to the target mobile platforms:</p><p><img src=../img/compilation.0bdc.png alt=Fig6> <em>Fig 6 - Compilation Process</em></p><h3>Angular js</h3><p>Developed and maintained by Google, Angular adds several advantages to the development process of JavaScript applications. The four main points to mention are:</p><ul><li><p>Two way data binding: Angular has models that bind to the view via a $scope. Every time a model changes its value, the view is updated. This reflects into shorter code that does not rely on DOM structure and manipulation. Freeing the developer to concentrate in the applications&#39; logic rather than its&#39; formatting.</p></li><li><p>Directives: When DOM manipulation is absolutely necessary, Angular provides directives, whereby developers can write reusable pieces of code that operate in a set of data in combination with the DOM structure. Throughout this application, a reusable directive has been used to cater for the search feature.</p></li><li><p>Structure: Angular adds structure to an application. Although commonly following an MVC architecture, Angular calls itself an MVW framework, which literally stands for Mode-View-Whatever, it lays out the guidelines, but leaves it up to the developer on how to best implement them. All applications typically have an entry point, called the run method; Templates can be decorated with directives and expressions, further DOM manipulation can be encapsulated within reusable Directives; Shared functionality can be created as services, which in turn can be configured during different points of the applications&#39; lifecycle; Code behind view blocks can be stored in controllers; application state can be managed via routes, filters provide formatting and filtering functionality; And it can all be grouped within modules, which are very similar to namespaces, other than modules will also declare their external dependencies and provide the methods to implement all the above.</p></li><li><p>Dependency Injection: As mentioned by Brian Ford in a Google developer conference, dependency injection can be defined with one sentence: &quot;Don&#39;t call me, I&#39;ll call you&quot;. What he means is that it is a design pattern that implements inversion of control, one of the SOLID principles. Instead of instantiating objects within our methods, we simply declare the dependencies in our methods&#39; signature, Angular will recognise the services a module depends on and will automatically inject the correct instantiated objects when that method is called during run time. This makes the methods more testable and more decoupled from one another, hence, immediately providing higher adherence to SOLID principles.</p></li></ul><p>In addition, this application makes use of an Angular service called Angular Local Storage, this dependency provides a simple API to interact with HTML5 local storage for different clients. It will also fall back to cookies, should Local Storage not be available in the current system.</p><h3>Ionic and Cordova</h3><p>In the core of this entire application is Ionic, a Framework for building hybrid (native/web) applications for smart devices (phones/tablets). Finding and deciding on using Ionic was the single most laborious research for this project.</p><p>Prototypes were written using different frameworks, most of those frameworks would either only have a set of UI interfaces or provide the low level integration required by Cordova, such as Topcoat and the Angular-Cordova bridge respectively. Nonetheless, Ionic that provided all the necessary tools and workflow to accomplish the final task in one framework.</p><p>Being backed by Drifty Co. a company that works closely with Google, and having their CEO, Max Lynch, writing the Angular.js port for Material Design, places Ionic in a very respectable position.</p><p>Despite all that, Ionic created and makes use of ngCordova a tool that seamlessly integrates Angular.js with Apache Cordova, making it easy to call the low level Cordova API without compromising on the application architecture.</p><p>It also provides a beautiful set of predefined UI elements and Directives that package them together for advance usage. Plus, Angular-UI-Router is already packaged in the bundle, so nested routes and states can also be implemented.</p><p>In addition, Ionic keeps an up-to-date forum and documentation, not to mention a nightly built code sample library on Code-Pen.</p><p>Ionic has also recently released a service called Ionic View, which allows developers to view and share their application on different mobile platforms without going through the hassle of deploying their app in any app store. And will soon release a push notification system, now closing the loop with all necessary services to develop complex hybrid mobile applications.</p><h3>Firebase</h3><p>Combining noSQL with a layer of WebSockets, comes Firebase, it is not only a database system in the cloud but also a full eco system that caters for security annotations on top of your data structure and oAuth integration with third party providers such as Facebook and Google+. This project integrates Firebase by means of a library called Angularfire. Angularfire is a library written by the Firebase team that aids easier integration with Angular, converting the application into a Three way data binding tool, when data changes in the database the view for all clients is immediately updated, real-time. Combining a top notch support team and being now part of Google, I am confident Firebase will soon become one of the biggest entities for backend solutions.</p><p>Chapter 7 develops further the obstacles imposed by Firebase, noSQL in general and the techniques employed to overcome those limitations.</p><h3>SASS/Compass</h3><p>This projects makes use of CSS pre-processors in order to simplify the stylesheets necessary to render the application. A Grunt task then aids it further, by means of running the compass watch task necessary to transform the SASS code into CSS. It also makes use of another task called Autoprefixer, which in turn prefixes CSS3 declarations with the browser vendors annotations. For example, as a developer, I may wish to use border radius for my buttons, my CSS class may look like the following:</p><div class=highlight><pre><code class=language-text data-lang=text>.btn {
  border-radius: 5px;
}
</code></pre></div><p>After running Autoprefixer, the browser vendors will be added like so:</p><div class=highlight><pre><code class=language-text data-lang=text>.btn {
  -webkit-border-radius: 5px;
     -moz-border-radius: 5px;
          border-radius: 5px;
}
</code></pre></div><p>This process runs automatically whenever a SASS file is changed throughout the application, providing, of course, that the Grunt serve tasks is running.</p><p>In addition, Compass, provides a full library of Mixins, aiding further with common CSS patterns. In the SASS world, CSS development is seen much like Object Oriented Development, that is, a class can be extended, variables can be created and even nesting is allowed. Mixins are simply a piece of reusable CSS, that can be mixed into any other CSS class.</p><h3>The SDKs&#39;</h3><p>Firstly, in order to develop an iOS application, one must be developing on a Macintosh computer, this is necessary since the SDKs&#39; come bundled with XCode a Mac specific application. Providing that, the set up for iOS is rather simplistic, one only needs to download and install XCode, accept the terms and conditions and ensure the command line tools are installed and available.</p><p>In the other hand, the Android SDK can be proven to be slightly more difficult to install and configure. The first dependency to be installed is the Java JDK, almost all the other dependencies can be met by means of installing the Android Studio, an excellent IDE built on top of the JetBrains IntelliJ. However, if you wish to develop in the terminal there are a few other things that must be made available on your path:</p><ul><li>The SDK platform-tools</li><li>The JAVA_HOME variable</li><li>Ant</li><li>ADB (The Android Debug Bridge)</li></ul><p>With all that in place, Android development should be possible, however, if that seems like too much overhead, Ionic offers a Vagrant box already preconfigured to develop Ionic apps for Android, it can be obtained from the link below:</p><p><a href=https://github.com/driftyco/ionic-box>https://github.com/driftyco/ionic-box</a></p><p>Vagrant is a Virtual Machines manager that integrates with Oracles Virtual Box. Both tools are available free of charge. Furthermore, it allows port forwarding and directories mapping with the local development system. The Vagrant box above, therefore allows Android development without the need to install and configure an Android environment.</p></div><div class=breakpage><h1>Chapter 4</h1><h2>Data Findings</h2><p>As a result, three applications were developed for this assignment, an Android application, an iOS application and a web application. In summary, all apps do not diverge from the original source code, they have simply been compiled for different platforms.</p><p>Unfortunately, by the time of this writing, the iOS application is still under approval by Apple, please keep on checking the live version of this documentation at the link below as it will be made available as soon as the app goes live:</p><p><a href=http://iou.rocks>http://iou.rocks</a></p><p>The Android application can be downloaded and installed from the link below:</p><p><a href="https://play.google.com/store/apps/details?id=com.jbonigomes.IOU">https://play.google.com/store/apps/details?id=com.jbonigomes.IOU</a></p><p>A web version of the application has also been made available at the following link:</p><p><a href=https://ioutest.firebaseapp.com>https://ioutest.firebaseapp.com</a></p><p>It is important to note that since the codebase for the web app and the mobile apps are the same, a greater amount of care has been taken towards the mobile apps, and therefore, the web application lacks a slight level completeness. The main issue lies within the fact that page refreshes may render the application unusable, should that occur, one must click the home button in the top left of the application then refresh the page again. This issue has been added to the backlog and once the web app is deemed to be sufficiently good it will be published in a new URL that does not contain the word &#39;test&#39; in it.</p><p>Chapter 6 develops further towards what is recommended for future improvements, however, an archiving system that was originally planned could not be implemented yet, this has however been added to the backlog and will be developed in a future version. To cover the lack of an archiving system, for now, users have the option to completely delete a list, IOU recommends to only delete a list once all members are satisfied that the amount owed to each other meets their expectancy.</p><h2>Information Architecture</h2><p>The information architecture for IOU takes in consideration the overall user experience aiming to logically group sections that relate to each other and layer them down based on importance.</p><p><img src=../img/information_architecture.efec.png alt=Fig7> <em>Fig 7 - Information architecture</em></p><p>Although not explicitly demonstrated, all states that require login present a link that goes straight back to the home page as well as a quick access slide menu that displays information about the currently logged user and present links to the home page, privacy page, terms and conditions page and logout.</p><h2>Angular Architecture</h2><p>The application dependencies look like the following diagram:</p><p><img src=../img/angular_architecture.79b5.png alt=Fig8> <em>Fig 8 - Angular architecture</em></p><p>Centrally located is the IOU module, where the applications&#39; run method is located, this module declares the external and internal dependencies that together form the final product.</p><h2>Use cases</h2><p>In addition to the information architecture depicted above, this section develops further into the user journey analysing each scenario a user may encounter.</p><p>The use case diagrams below assumes that &#39;Common Links&#39; refers to the following links:</p><ul><li>Home page</li><li>Terms and Conditions page</li><li>Privacy Policy page</li></ul><p>Also, the diagrams do not explicitly show that for every stage that requires a login, a logout link is also provided.</p><p>Before having access to the application, the user must first accept the terms and conditions and login.</p><p><img src=../img/use_login.da0c.png alt=Fig9> <em>Fig 9 - Login Use Case</em></p><p>The home page shows all lists that the current logged user belongs to. Allows creating, editing, deleting and filtering lists. Each list also displays their total in relation to the logged user. The top of the page should give a summary of the whole total between all lists in relation to the currently logged in user.</p><p><img src=../img/use_home.8441.png alt=Fig10> <em>Fig 10 - Home Use Case</em></p><p>The products view should display a list of all products that are due to be bought as well as all the products that have been bought. It should allow creating new products, buying products and editing products. It should also display a total for the current list in relation to the logged in user.</p><p><img src=../img/use_products.f23f.png alt=Fig11> <em>Fig 11 - Products Use Case</em></p><p>The members view should show all members that belong to the current list. Each member should be displayed with a calculated field of how much they owe or are owed in relation to the currently logged in user. The same list overall total that appears in the products page should be displayed at the top of the members page too. From the members view, new members could also be added.</p><p><img src=../img/use_members.b6ac.png alt=Fig12> <em>Fig 12 - Members Use Case</em></p><p>The user workflow for using the IOU app should look like the following:</p><ul><li>When a user remembers that something has to be bought, a new item should be created in the products view.</li><li>When this newly created product is bought in the &#39;real world&#39;, the user should &#39;buy&#39; this product within IOU, by means of adding a price to the given product.</li><li>Once all members decide it is time to close the list, they should check the members tab to know how much they owe each other.</li><li>Finally, in the &#39;real world&#39; they should exchange the proposed amounts then delete the list from IOU.</li></ul><h2>Application Structure</h2><p>The following is the file structure powering IOUs&#39; source code, this is the default structure created by Diego Nettos&#39; Yeoman Generator:</p><div class=highlight><pre><code class=language-text data-lang=text>├── Gruntfile.js        - Configuration of all Grunt tasks
├── package.json        - Dev dependencies and required Cordova plugins
├── bower.json          - Lists front-end dependencies
├── config.xml          - Global Cordova configuration
├── .gitignore          - Best practices for checking in Cordova apps
├── resources/          - Scaffolded placeholder Icons and Splashscreens
│   ├── ios/
│   ├── android/
├── app/
│   ├── index.html      - Main Ionic app entry point
│   ├── lib/            - Libraries managed by Bower
│   ├── scripts/        - Custom AngularJS Scripts
│   ├── styles/         - Stylesheets
│   ├── templates/      - HTML views
├── platforms/          - Targeted operating systems
├── plugins/            - Native plugins
├── hooks/              - Cordova lifecycle hooks
├── merges/             - Platform specific overrides
├── coverage/           - Istanbul reports
├── test/               - Unit tests
│   ├── spec/
├── www/                - Copied from app/ to be used by Cordova
</code></pre></div></div><div class=breakpage><h1>Chapter 5</h1><h2>Analisys Evaluation</h2><p>After completing the IOU application, one major concern was how smooth the animations and transitions would perform in a real device. Up to that point, the application was only tested using emulators.</p><p>Surprisingly, as opposed to the bad reputation of hybrid apps performance, IOU responds quite well on Android devices.</p><p>Unfortunately, by the time of this writing, Apple is still reviewing IOU and, I am, therefore unable to comment on its&#39; performance yet.</p><h2>Testing</h2><p>IOU has been tested with several users, each of which presented their own problems, most of which were not bugs but simply different points of view on how the workflow should be approached.</p><p>The main goal of getting users to test the application early, was to not only collect early feedback, but also to ensure that the application validates and handles user input correctly, as well as ensure that the calculation algorithms work correctly.</p><p>The scenarios tested were:</p><ul><li><p>Login</p><ul><li>Can log in with valid Facebook credentials</li><li>Cannot log in with invalid Facebook credentials</li><li>Must accept the terms and conditions before login</li><li>User can read the terms and conditions</li><li>User can read the privacy policy</li><li>User can visit IOUs&#39; home page</li></ul></li><li><p>Home</p><ul><li>Only the lists that the currently logged user belongs to should be visible</li><li>User can create a new list</li><li>User can delete a list</li><li>User can edit a list</li><li>Name and image</li><li>An overall calculation of all lists in relation to the currently logged in user should be presented</li><li>Clicking on a list should navigate to the products view of that list</li></ul></li><li><p>Products</p><ul><li>A total of the current list in relation to the currently logged in user should be presented in the top of this page</li><li>User can create a new product</li><li>A new product should appear as a &#39;To buy&#39; product</li><li>User can buy a &#39;To buy&#39; product</li><li>User can edit products that have been bought</li><li>Owner</li><li>Price</li><li>Name</li><li>A product that has been edited, must display an &#39;@amended&#39; tag</li></ul></li><li><p>Members</p><ul><li>A total of the current list in relation to the currently logged in user should be presented in the top of this page</li><li>A list of all members that belong to the current list should be displayed here</li><li>Each member should display a calculated field of how much he/she owes or is owed in relation to the current logged in user</li><li>A new member can be added to this list</li></ul></li><li><p>All</p><ul><li>Pages that require a login should present common links:</li><li>Home</li><li>Terms and conditions</li><li>Privacy policy</li><li>Logout</li><li>Validations</li><li>Any price entered must be a numeric value that is bigger than 0</li><li>All string fields are required and must therefore be completed</li></ul></li></ul><p>Each scenario was tested using different inputs to ensure that the appropriate validations triggered correctly.</p><h2>The future</h2><p>Unfortunately, due to the tight deadline for this project, automated testing could not be implemented, however, the set up for this to happen is already in place and tests will be written in future iterations.</p><p>The most exciting testing framework present is Protractor, and End-to-end testing framework developed specifically for Angular.js.</p><p>Protractor uses a Selenium driver to simulate users actions and ensure the expected outcome is met.</p><p>In addition, Mocha and Chai are already set up to perform the unit tests, those tests run using Angulars&#39; Karma Runner and using Istanbul, produce static websites with the results and the code coverage stats.</p></div><div class=breakpage><h1>Chapter 6</h1><h2>Conclusion and Recommendations</h2><p>As a final result, this project delivered the planed basic set of features. Users are already using it and the project has been proven to be fit for purpose.</p><p>Although still being in the process of being approved by Apple, the Android version is already live and iOS users have access to the alternative web version.</p><p>Despite all that, the list below has been compiled from the feedback heard from users and will be addressed in future iterations:</p><ul><li>Send a welcome email when user registers for the first time</li><li>Create an explanation video to be displayed in the app store</li><li>Display message and disable all functions when user is offline</li><li>Send a push notification when a user is added to list by someone else</li><li>Improve overall look an feel such as adding a back button where relevant</li><li>Make the app more snappy (this may include compile the add along with Crosswalk, a full version of the Chromium browser)</li><li>Improve the web version, the current list and product id being edited should be saved to local storage in case the user presses the browser refresh button.</li><li>have a loading icon when pages are being loaded with an overlay that does not allow users to interact with the application until its&#39; state is ready</li></ul><p>In addition, creating a concept of list owners may be a good idea, therefore a list can only be managed by whomever created it, instead of allowing all participants to take this role. In this case, only a list owner can:</p><ul><li>Delete products</li><li>Archive/close a list</li><li>Add support for different languages</li><li>Remove a user from a list<ul><li>If he/she did not buy anything yet, delete the user</li><li>Otherwise, have a warning message allowing the delete action to be canceled add state that removing this user will also remove all products he/she has bought</li></ul></li></ul><p>Some extra features could also improve the final product:</p><ul><li>Add different currencies</li><li>Create an invite friends feature</li><li>Add a users guide/help page within the app</li><li>Allow archiving lists, so that a list is never deleted should users want to review it some time in future</li></ul><p>In terms of the codebase, due to the small size of this application, files have been grouped based on how Angular qualifies them, that is, if it is a Directive, it goes to the directives file and so on. However, as the application expands, this pattern may no longer be sustainable. Grouping files by feature will be a better option as the app expands. More specifically, the file that would benefit from this pattern the most is the controllers file. This approach has been demonstrated by several experts in the field, including Pawel Kozlowiski and Sandeep Panda.</p><p>Simply as a proof of concept, proving that Ionic and Cordova can produce a hybrid mobile app to all major platforms, it may be a good idea to compile the application for both Blackberry and Windows phone.</p><p>Although already mentioned in Chapter 5, implementing automated tests will be paramount in future versions of this app.</p><p>Finally, this project demonstrated that it is possible to create hybrid mobile phone apps using web technologies. Although fundamentally similar, mobile development comes with a different set of problems to be solved, most of which are technically challenging. However, completing this project gives me the confidence and enthusiasm to improve it in future and engage in new exciting development endeavours.</p></div><div class=breakpage><h1>Chapter 7</h1><h2>Review/Reflections</h2><p>This chapter reflects on the challenges encountered while developing IOU. Each section develops further on what those challenges were and how they were approached.</p><h3>The IOU algorithm</h3><p>The entire application would be meaningless if a good money splitting algorithm was not implemented. It seems money splitting algorithms are somewhat complicated to implement successfully. Moreover, IOU not only aims to split expenses in a fair manner, but also, optimise the change each participant has to pay, so that users do not need to exchange money among each other more than once.</p><p>The first step taken followed Steve Bobs&#39; approach:</p><p>http://stevebob.net/iou/howitworks.html</p><p>This is only a pseudocode that had to be implemented in JavaScript ensuring that the concept works in a real life scenario.</p><p>The final algorithm can be found in the source code under &#39;app/scripts/services.js&#39; under a factory called MembersWithTotal.</p><p>The algorithm works as follow:</p><div class=highlight><pre><code class=language-text data-lang=text>calculate the list total
calculate how much each individual user spent in the list
calculate the list average by dividing the total per the number of users
calculate how much has been overspent, this is the sum of the difference between the amount of money each member has spent and the list average
qualify the current logged user as a &#39;creditor&#39;, &#39;debtor&#39; or &#39;even&#39;, a user is a &#39;debtor&#39; if he/she spent less than the list average, a &#39;creditor&#39; if he/she spent more and &#39;even&#39; if he/she spent the exact same amount as the list average

if the logged user is a creditor
  for each debtor
    calculate a percentage owed to the current logged in user, this is the percentage of the total overspent that the current logged user has spent
    based on how much the debtor has underspent, calculate how much he/she owes to the current logged user by &#39;slicing&#39; his/her percentage (calculated right above)
    also keep accumulating this number to present as a list overall total

if the logged user is a debtor
  for each creditor
    calculate a percentage the current logged in user owes to the creditor, that is, from the total list overspent, this will be the percentage the creditor has overspent
    based on how much the current logged in user has underspent, calculate how much he/she owes the creditor by &#39;slicing&#39; his/her percentage (calculated right above)
    also keep accumulating this number to present as a list overall total

Otherwise, the logged user must have spent the exact same amount as the list average and therefore does not owe or is owed any money, zero can be returned as the his/her total
</code></pre></div><p>Arriving at this final algorithm required a successive amount of trial and error. Although not particularly elegant, and somewhat naive, after testing with several users, amounts and scenarios, I believe it calculates the totals correctly.</p><p>Following the above, the way the optimised change works is that it will only return one of three scenarios:</p><ul><li>An even list, which means, no actions for the user, he/she spent the ideal amount</li><li>A creditor list, this user does not have to pay any money and is simply informed how much he/she is owed</li><li>A debtor list, this user owes money to the creditors, the app will notify how much is owed to each member</li></ul><p>There is still room for improvement over how this process work, most of which goes towards the efficiency and readability of the JavaScript implementation. Going forward, once the unit tests for this factory have been written, more effort will be applied in its&#39; mathematical foundations.</p><h3>Data architecture</h3><p>Coming from a relational databases background, one of the most difficult mind set to adapt, was to start thinking in a noSQL way.</p><p>In noSQL, data is stored as key value pairs, which in turn, can hold nested key value pairs, in practice, data is represented as a JSON notation object that can be queried by traversing the tree structure.</p><p>The IOU app is powered by, Firebase, an implementation of a noSQL database, that although very fast and scalable comes with a few limitations, for example, it only allows a depth of up to 32 levels when nesting data objects and although data can be queried as arrays, it does not support storing data as arrays, all values must be strictly stored as JSON key value pairs.</p><p>From the Firebase documentation, the initial data structure was organised as the sample JSON object below:</p><p>https://www.firebase.com/docs/web/guide/structuring-data.html</p><div class=highlight><pre><code class=language-text data-lang=text>{
  &quot;lists&quot;: {
    &quot;123&quot;: {
      &quot;name&quot;: &quot;Households&quot;,
      &quot;image&quot;: &quot;lightbulb&quot;,

      &quot;members&quot;: {
        &quot;444&quot; : true,
        &quot;555&quot; : true
      }

      &quot;products&quot;: {
        &quot;567&quot; : true,
        &quot;891&quot; : true
      }
    },

    &quot;234&quot;: { ... },

    &quot;345&quot;: { ... }
  },

  &quot;products&quot;: {
    &quot;567&quot; : {
      &quot;amended&quot; : true,
      &quot;date&quot;    : 1412635438623,
      &quot;name&quot;    : &quot;Potatoes&quot;,
      &quot;owner&quot;   : &quot;444&quot;,
      &quot;price&quot;   : &quot;28&quot;
      &quot;bought&quot;  : true
    },

    &quot;891&quot; : { ... }
  }

  &quot;members&quot;: {
    &quot;444&quot;: {
      &quot;name&quot; : &quot;Jose Gomes&quot; 
    },

    &quot;555&quot;: { ... }
  },
}
</code></pre></div><p>In contrast with a more traditional relational data structures, there is not much going on in the sample above. There are three main collections (lists, products and members) and each hold a series of entries, represented by a unique key which in turn holds the values for that row. The only extraneous notation is how the relations are declared, instead of foreign keys, Firebase recommends setting relations like so:</p><div class=highlight><pre><code class=language-text data-lang=text>&quot;members&quot;: {
  &quot;444&quot; : true,
  &quot;555&quot; : true
}
</code></pre></div><p>This may look intriguing at first, however, since Firebase does not support arrays in their storage, this is the nearest achievable way to represent a one-to-many relation.</p><p>Although easy to understand, this initial set up does not make use of the full potential from a noSQL database, within a key value architecture, the developer is not constrained to the limitations of data normalisation, the database can be moulded in whichever way it best suits the application using it. Besides, joins considerably deteriorate the performance of data processing.</p><p>The following blog post by Anant Narayanan, was the first stage in denormalising the initial concept:</p><p>https://www.firebase.com/blog/2013-04-12-denormalizing-is-normal.html</p><p>In conversation with Sara Robinson, Developer Evangelist at Firebase, during the a Google Developers Conference, it became clearer that a more nested structure would boost the application performance yet making it easier to perform queries that return meaningful data with less processing.</p><p>As a result, the second iteration architecturally looks like the following:</p><div class=highlight><pre><code class=language-text data-lang=text>{
  &quot;lists&quot; : {
    &quot;123&quot; : {
      &quot;name&quot;  : &quot;Households&quot;,
      &quot;image&quot; : &quot;lightbulb&quot;,

      &quot;bought&quot; : {
        &quot;567&quot; : {
          &quot;amended&quot; : true,
          &quot;date&quot;    : 1412635438623,
          &quot;name&quot;    : &quot;Potatoes&quot;,
          &quot;owner&quot;   : &quot;444&quot;,
          &quot;price&quot;   : &quot;28&quot;
        },
        &quot;891&quot; : { ... }
      },

      &quot;tobuy&quot; : {
        &quot;678&quot; : {
          &quot;date&quot; : 1412635438623,
          &quot;name&quot; : &quot;Steak&quot;
        },
        &quot;789&quot; : { ... }
      },

      &quot;members&quot;: {
        &quot;444&quot; : true,
        &quot;555&quot; : true
      }
    },

    &quot;234&quot; : { ... },

    &quot;345&quot; : { ... }
  },

  &quot;members&quot; : {
    &quot;444&quot; : {
      &quot;name&quot; : &quot;Jose Gomes&quot;
    },

    &quot;555&quot; : { ... }
  }
}
</code></pre></div><p>Since the IOU app differentiates products that have been bought from products that are still due to be bought, the first step taken was to break down products into two categories (bought and tobuy). This, in turn, raised the awareness that both structures did not have the same attributes. Secondly, since a set of products belong to a list only, much like a one-to-many relationship, it was only natural to nest those two new objects within a list object, those two actions not only improved the speed to which data can be read, but also represent, if not, describe, the IOU app architecture.</p><p>Finally, during the last iteration and after coming to a realisation of how Firebase security rules work, it was decided that a collection of members was not necessary. This decision was made for two reasons, firstly, simply to make the structure cleaner, thus completely avoid joins and secondly because the objects are too simple, the only data stored is their Facebook id and their names. Besides, if a username is stored in the database, should the user update his/her name on Facebook, IOU will never be notified and will therefore always display an out-of-date username. The final data structure simply removes the members object completely:</p><div class=highlight><pre><code class=language-text data-lang=text>{
  &quot;lists&quot; : {
    &quot;123&quot; : {
      &quot;name&quot;  : &quot;Households&quot;,
      &quot;image&quot; : &quot;lightbulb&quot;,

      &quot;bought&quot; : {
        &quot;567&quot; : {
          &quot;amended&quot; : true,
          &quot;date&quot;    : 1412635438623,
          &quot;name&quot;    : &quot;Potatoes&quot;,
          &quot;owner&quot;   : &quot;444&quot;,
          &quot;price&quot;   : &quot;28&quot;
        },
        &quot;891&quot; : { ... }
      },

      &quot;tobuy&quot; : {
        &quot;678&quot; : {
          &quot;date&quot; : 1412635438623,
          &quot;name&quot; : &quot;Steak&quot;
        },
        &quot;789&quot; : { ... }
      },

      &quot;members&quot;: {
        &quot;444&quot; : true,
        &quot;555&quot; : true
      }
    },

    &quot;234&quot; : { ... },

    &quot;345&quot; : { ... }
  },
}
</code></pre></div><p>This final decision raises one last problem, now every time a use is displayed, an AJAX call must be made to Facebooks&#39; Graph API in order to return a users&#39; username. Although simplistic, this approach generates a non-obvious problem, when retrieving a list of users of unknown length, we have to wait for all Asynchronous calls to be finished before rendering the list.</p><p>Before going on details, it is important to clarify what a promise is. In Angular.js, most Asynchronous calls are treated as promises, this concept is not new, as mentioned in Wikipedia, the term promise was proposed in 1976 by Daniel P. Friedman and David Wise, and Peter Hibbard called it eventual. However, in the JavaScript world, it&#39;s implementation is still taking &#39;baby steps&#39;. In Angular.js, when a function is meant to return the result of an asynchronous call, an AJAX call for example, this call will be said to return a promise that will be resolved some time in the future. For example, one may wish to stipulate what should be done in the event of an error, or bind the data returned to a model in the event of a successful call.</p><p>Fortunately, Angular provides a service called $q, this service is packed with methods that aid promises handling. This project uses a method of $q called all(). The all() method receives two arguments, the first is an array of promises and the second is a callback function that will be executed when all the promises in the array are resolved, in addition, the data returned by each promise will be packed as an array and passed as an argument to this function. Taking this approach resolved the problem imposed when rendering a list of users, the code sample below has been used the the users:</p><div class=highlight><pre><code class=language-text data-lang=text>// userswithnames refers to an array of promises
// created making sucessive AJAX calls to Facebooks&#39;
// Graph API, based in the stored user ids&#39;
$q.all(userswithnames).then(function(members) {
  // bind each member to the view
});
</code></pre></div><p>In addition, to minimise the number of AJAX calls, since the member that is currently logged in will have his/her data presented throughout most states of the application, during login time IOU will store the users information on Local Storage, hence minimising the usage of $q only to render the members list view.</p><p>Finally, although not closely related with the data structure, getting acquainted with handling asynchronous calls in JavaScript has been paramount to the success of this project. Although Firebase simplifies the data handling with Angular.js by means of using Angularfire, in addition to the $q problem described above, sometimes when data is updated outside the Angular application a new digest loop has to be triggered. This problem has been overcome by setting up a watcher in the root of the Firebase data architecture, every time data changes in Firebase, this watcher is notified and will then run a data refresh within the given controller.</p><h3>oAuth</h3><p>Despite simplifying the entire oAuth process with third parties, Firebase still requires some configuration in order to work as expected.</p><p>Since IOU uses Facebook authentication, the first step is to create a Facebook developer account, then generate a new Facebook app. This process will create an unique Facebook app ID and a secret key. Those two parameters must then be configured accordingly inside Firebase&#39;s admin panel.</p><p>The next step is to choose an appropriate firebase oAuth method, there are several options, however, IOU is constrained to use the authWithOAuthPopup method, since it is supported both on all major web browsers and within Cordova&#39;s In-App-Browser extension.</p><p>The final step is ensure sufficient information about the users is collected from Facebook during the login process. this is done via a scope variable, IOU collects the basic public user information, such as the users email address, profile picture and full name, in addition, IOU will also ask permission to have access to the users friends list.</p><p>It is important to note that although IOU has access to the users friends list, Facebook will only return the list of friends of a user that also happen to be an IOU user. This limitation exist to avoid abuses such as spamming, but can, however be quite confusing for a first time Facebook app developer.</p><p>Once all this is in place, Firebase will take care of all the rest, such as token management and providing a consistent API for logging users in and out of the application as well as providing basic information about users and authentication status.</p><h3>Security rules</h3><p>Firebase provides a set of annotations that follow the data structure of the application. In addition to authentication, those annotations dictate who has access to read and write specific sets of data.</p><p>It is important to note that the security rules are not part of the application code, those annotations are set up in the server via Firebase&#39;s admin panel and are therefore not visible even to those who have access to the application source code.</p><p>Once a user is logged in, Firebase will assign a variable named auth, which is null by default, to an object containing the logged user information. Rules can then be written to ensure that a given user does not have access to data he/she should not have access to.</p><p>Much like the Firebase structure, those rules are written in a JSON format and follow the same structure of the Firebase data. For example, in order to control access of a list, so that only users that belong to a list can view and edit it, the following rule may be used:</p><div class=highlight><pre><code class=language-text data-lang=text>{
  &quot;rules&quot;: {
    &quot;.read&quot;: false,
    &quot;.write&quot;: false,
    &quot;lists&quot;: {
      &quot;$list&quot; {
        &quot;.read&quot;  : &quot;(root.child(&#39;members/&#39; + auth.uid).val() === auth.uid)&quot;,
        &quot;.write&quot; : &quot;(root.child(&#39;members/&#39; + auth.uid).val() === auth.uid)&quot;,
      }
    }
  }
}
</code></pre></div><p>In order to test security rules, Firebase provides a tool in their admin interface which simulates data reads and writes.</p><p>When developing more complex rules, Firebase has created a tool called Blaze, which compiles Yaml formatted data into workable security rules and allows usage of reusable variables and functions.</p><h3>Play and App stores</h3><p>Last but not least, as opposed to web applications, apps published in the Google Play Store and Apple App Store, must be digitally signed. Each platform operates in a different way, however the principle is the same, the developer generates a key that is used to sign the first version of the application. Subsequent updates to the same will have to be signed with the same key.</p><p>Apple makes this process easier within Xcode, the generated key is automatically added to the developers keychain and the signing process is carried out seamlessly within Xcode.</p><p>Android has a slightly more complicated process, whereby three steps are necessary when creating the first version of an app:</p><ul><li><p>Firstly, a key must be generated, replacing &#39;my-release-key&#39; with the desired key name and &#39;alias_name&#39; with the desired alias name:</p><p>$ keytool -genkey -v -keystore my-release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000</p></li><li><p>This command will produce a key, and it is the developers&#39; responsibility to keep it safe for future updates, the key generation process will ask several questions about the developers identity and will ask for a password to be created in the end of the process.</p></li><li><p>The next step involves signing the unsigned app with the newly generated key:</p><p>$ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore HelloWorld-release-unsigned.apk alias_name</p></li><li><p>Finally, the apk that will be uploaded to the Play Store can now be generated:</p><p>$ zipalign -v 4 HelloWorld-release-unsigned.apk HelloWorld.apk</p></li></ul><p>It is worth mentioning that the first step should only be executed once, subsequent updates will then reused the key for the jarsigner before it can be zipaligned. Failure to provide the same key will block the app from being updated.</p></div><div class=breakpage><h1>Chapter 8</h1><h2>References</h2></div><div class=breakpage><h1>Chapter 9</h1><h2>Bibliography</h2><p>conrad barski land of lisp</p><p>paul graham hackers and painters</p><p>Quentin Charatan and Aaron Kans java in two semesters</p><p>Robert Bruce Findler, Matthew Flatt, Shriram Krishnamurthi, Matthias Felleisen How to design programs</p><p>Gerald Jay Sussman, Hal Abelson structure and interpretation of computer programs</p></div><div class=breakpage><h1>Appendices</h1><h2>Appendix A - About this documentation</h2><h3>The dilemma</h3><p>At the time of this writing, I faced a dilemma, which word processor is the best processor for writing this documentation.</p><p>The most obvious choices were:</p><ul><li>Microsoft Word</li><li>Apple Pages</li><li>Google Docs</li></ul><p>Surely any of the choices above would be suitable, however, in my humble opinion, such options can be somewhat &#39;evil&#39; when it comes to document formatting, turning most documentation written in one platform unreadable in the other or to the very least almost certainly not looking as intended.</p><p>In general, converting the document to a PDF format remediates this problem, however, I am now left with the fact that my content is tightly coupled to the editor that created the documentation. Modification is difficult, for example, someone else may wish to edit the document, or perhaps if at some point in time in the near future I decide to present my documentation as an HTML document on the web, or perhaps as a deck of slides or even publish it in a book format, I may have to revise the entire text looking for any &#39;evil&#39; formatting issues that was not visible in the former format.</p><p>Finally, as a writer, when writing documentation, I should concentrate on writing the documentation, and not about auto generated formatting issues that may arise and drag productivity in a typical writing session. The writer should only worry about the semantics and the content of his/her writing, formatting should be done separately, perhaps not even by the writer himself, or better, simply choose a new format from predefined options written by a talented designer.</p><p>LaTeX is a really good option to move away from the formatting problems mentioned above, and beyond, however, it does trap the writer with a little clutter to tinker with in terms of settings and so on. What I am trying to say is, once the document is finalised, it no longer consists of the content and the content only, but also carries several formatting tags. This in one hand demonstrates how powerful LaTeX can be, but in the other, may confuse and distract the writer.</p><h3>The solution</h3><p>Since this course is about computer science, I set off to find a solution that would allow me and any other developer to run away from the masses and write simple interchangeable documentation with ease. Writing a solution that could potentially be further enhanced to the point a non programmer could also benefit from.</p><p>The requirements were:</p><ul><li>Write content and content only, without distractions</li><li>Formatting should be written separately and be interchangeable/themeable<ul><li>This also means that if some time in future I want to publish my content to a different type of media, I should be able to do so without too much effort</li></ul></li><li>It should not be coupled to any specific text editor</li><li>It should have an automated building and deployment solution</li></ul><p>The answer was always there, Markdown. Markdown is a really simple and easy to use markup language, it is the de facto standard for readme files in software development and widely used in blogs throughout the web.</p><p>A short introduction to Markdown syntax can be found in the link below:</p><p><a href=http://daringfireball.net/projects/Markdown/syntax>http://daringfireball.net/projects/Markdown/syntax</a></p><p>Although Markdown may not be as powerful as LaTeX, the community around it is immense and really keen in providing further enhancements to it, the following link lists many projects and plugins that address some of those short-comes:</p><p><a href=https://github.com/cben/mathdown/wiki/math-in-Markdown>https://github.com/cben/mathdown/wiki/math-in-Markdown</a></p><p>The community also provides an excellent open source Markdown editor called Mou, although Mac specific, all other major operating systems have free alternatives to Mou:</p><p><a href="http://25.io/mou/">http://25.io/mou/</a></p><p>Finally, there is an open source project which is now maintained by Jakob Truelsen and Ashish Kulkarni, called wkhtmltopdf, this headless command line tool, allows any HTML document to be converted to PDF, and since Markdown is easily convertible to HTML, we now have all the tools we need in order to create our documentation.</p><p><a href="http://wkhtmltopdf.org/">http://wkhtmltopdf.org/</a></p><h3>The workflow</h3><p>To make this work, we will need to automate every step of the process, so that we can only write Markdown, then compile/deploy our work with only one command and in the process, if we wish to do so, add some personalised styles to our document.</p><p>The application that holds the documentation has been scaffolded using Yeoman, more specifically, using a generator called generator-jekyllrb.</p><p><a href=https://github.com/robwierzbowski/generator-jekyllrb>https://github.com/robwierzbowski/generator-jekyllrb</a></p><p>Although Yeoman is an NPM package, backed by Node.js, it combines three simple but powerful Ruby Gems:</p><ul><li>Jekyll: A static blog generator created by the GitHub Team. It provides an easy to use templating language called Liquid as well as giving the means to transform Markdown files into HTML, finally compiling the entire application into deployable static websites.</li><li>Redcarpet: A Markdown to HTML converter.</li><li>Compass: A CSS pre-processor extension of SASS.</li></ul><p>Moreover, Jekyll makes it really easy to deploy and host your application directly on Github free of charge.</p><p>This Yeoman generator also leverages the power of Grunt and Bower into the workflow.</p><p>Most of the Grunt tasks used for this documentation have also been used for the main IOU application, however, a few notable differences are mentioned below:</p><ul><li>grunt-build-control: Allows deployment to Github via Git.</li><li>grunt-jekyll: integrates Jekyll with Node.js.</li><li>grunt-wkhtmltopdf: Compiles HTML files to PDF.</li></ul><h3>Developing locally</h3><p>To use this workflow for other projects or simply try out what has been created so far, please follow the following instructions and make sure all dependencies are met and available on your path:</p><p>Dependencies:</p><ul><li>Git</li><li>Ruby and Ruby Gems<ul><li>SASS</li><li>Compass</li><li>Jekyll</li></ul></li><li>Node.js and NPM<ul><li>Grunt</li><li>Bower</li></ul></li><li>wkhtmltopdf</li></ul><p>Git clone this repository and <code>cd</code> into it:</p><div class=highlight><pre><code class=language-text data-lang=text>$ https://github.com/jbonigomes/ioudocs &amp;&amp; cd $_
</code></pre></div><p>Install the NPM packages:</p><div class=highlight><pre><code class=language-text data-lang=text>$ npm install
</code></pre></div><p>Install the Bower dependencies:</p><div class=highlight><pre><code class=language-text data-lang=text>$ bower install
</code></pre></div><p>Serve the app:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt serve
</code></pre></div><p>Other than <code>serve</code>, you may wish to run:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt serve:dist
</code></pre></div><p>The latter will first build the application then serve the optimised code, the former, may be a better option when debugging as files will not be minified and changes will be automatically refresh in the browser using &#39;browser sync&#39;.</p><p>Once displayed in the browser, you may wish to explore the documentation and view the PDF generated version too, link found right below the left navigation bar.</p><p>The directory structure will look as follow:</p><ul><li>.jekyll</li><li>.sass-cache</li><li>.tmp</li><li>app</li><li>dist</li><li>node_modules</li></ul><p>And the root directory hold the following files:</p><ul><li>.bowerrc</li><li>.csslintrc</li><li>.editorconfig</li><li>.gitattributes</li><li>.gitignore</li><li>.jshintrc</li><li>_config.build.yml</li><li>_config.yml</li><li>bower.json</li><li>Gemfile</li><li>Gruntfile.js</li><li>package.json</li></ul><p>The top most directories, prefixed with a dot &#39;.&#39; only hold temporary files required by Jekyll to serve the application locally.</p><p>All files in the root directory are common configuration files for Git, Jekyll and Node.js.</p><p>The node_modules directory holds all the Grunt tasks.</p><p>The app directory is where we, developers will actually work.</p><p>The dist directory holds the last build from our application, that is, the result of our code. For every build, Grunt will delete this directory and re-create it based on our changes. The dist directory holds the optimised code that is ready for production.</p><p>The app directory tree structure looks like this:</p><ul><li>_bower components</li><li>_includes</li><li>_layouts</li><li>_posts</li><li>_scss</li><li>docs</li><li>fonts</li><li>img</li><li>js</li><li>pdf</li></ul><p>The top most directory <code>_bower_components</code> holds the Bower dependencies. All the directories prefixed with an underscore &#39;_&#39; will not be copied to the dist directory during the build process.</p><ul><li>_includes: holds the cover page and the xsl file used to generate the table of contents in the PDF.</li><li>_layouts: hold the layout for the main web page, the layout for the documentation page and the layout for the PDF file.</li><li>_posts: holds the actual Markdown that makes up this documentation, they have been separated by chapters.</li><li>_scss: the SASS styles for the app and the print.scss, used by the PDF file.</li><li>docs: holds the documentation landing page.</li><li>fonts: the web fonts used in this project.</li><li>img: the images.</li><li>js: the JavaScript.</li><li>pdf: a placeholder HTML file containing all chapters and extending the PDF layout, as well as the actual generated PDF file.</li></ul><p>During your workflow, you may notice that the PDF file looks well formatted when running <code>grunt serve:dist</code> however, this statement does not hold true when running <code>grunt serve</code>, this is because Jekyll compiles the temporary CSS file in a different location when running on debug mode, to avoid too much overhead, when testing the PDF&#39;s layout you may use this short-hand:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt build
</code></pre></div><p>This will build the latest changes and save them under the dist directory, including a well formatted PDF file. You may now open the PDF directly:</p><div class=highlight><pre><code class=language-text data-lang=text>$ open dist/pdf/index.pdf
</code></pre></div><p>If you wish to deploy this app to GitHub, you will need to update the remote option in the buildcontrol task, found in the Gruntfile.js, swap it with a valid GitHub Page repository path, more details about GitHub Pages, Jekyll and BuildControl can be found in the link below:</p><ul><li><a href="https://pages.github.com/">https://pages.github.com/</a></li><li><a href="http://jekyllrb.com/">http://jekyllrb.com/</a></li><li><a href=https://github.com/robwierzbowski/grunt-build-control>https://github.com/robwierzbowski/grunt-build-control</a></li></ul><p>Once set up, you may deploy your code using:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt deploy
</code></pre></div><h3>Roadmap</h3><ul><li>Keep improving this workflow and gathering feedback from others on how to improve it.</li><li>Create a more generic version to use as a starting point for future documentations, perhaps a Yeoman generator.</li><li>Fix the issue with no styles in the PDF&#39;s generated with <code>grunt serve</code>.</li><li>Create new themes for the Markdown&#39;s, so far it is using the generic GitHub flavour styles.</li></ul><h3>Details</h3><p>The source code for this documentation can be found at:</p><p><a href=https://github.com/jbonigomes/ioudocs>https://github.com/jbonigomes/ioudocs</a></p><p>The latest built source for this documentation can be found at:</p><p><a href=https://github.com/jbonigomesbbk/jbonigomesbbk.github.io>https://github.com/jbonigomesbbk/jbonigomesbbk.github.io</a></p><p>And the final outcome here:</p><p><a href="http://iou.rocks/">http://iou.rocks/</a></p></div><div class=breakpage><h2>Appendix B - Users Guide</h2><p>This is the users guide for IOU app:</p><p><a href=http://iou.rocks>http://iou.rocks</a></p><p>IOU allows keeping track of expenses with Facebook friends.</p><p>Why use IOU?</p><ul><li><p>Every time you remember to buy something, just like a shopping list, for example:</p><ul><li>When the washing power is reaching its&#39; end</li><li>When making a list of groceries for the next BBQ party</li></ul></li><li><p>Every time you go shopping, consult your IOU lists</p></li><li><p>Every time you buy something that should be shared with your friends</p></li></ul><p>IOU lets you create lists. A list is a container which holds three other lists:</p><ul><li>The members of this list</li><li>The products you wish to buy</li><li>The products bought in this list</li></ul><p>IOU will keep you informed of how much you spent and based on how your lists are grouped.</p><p>A list can be closed at any time, simply glance at the members view before closing it to know how much you owe or how much each member owes you.</p><p>To get started, you must log in using your Facebook, IOU will never share your information with 3rd Parties, neither will it create posts on your behalf.</p><p>Before login, you must read and accept the terms and conditions:</p><p><img src=../img/screen_1.bd64.png alt=Help1></p><p>Unless one of our friends has already added you to an existing list, chances are that your first screen will look blank, the first step is to create a new list, clicking the &#39;NEW&#39; button in the bottom of the page:</p><p><img src=../img/screen_2.0ede.png alt=Help2></p><p>Let&#39;s name our list, Households, since it will be a list with items that we share with our housemates. We will also choose the bag icon for this list:</p><p><img src=../img/screen_3.586c.png alt=Help3></p><p>We now have our first list, please note the search box at the top, if we have many lists this feature can come handy to quickly find the list we want. Lets click on it to explore further:</p><p><img src=../img/screen_4.f12d.png alt=Help4></p><p>Our list is still empty, we can add a new product by pressing the &#39;NEW&#39; button in the bottom of the page:</p><p><img src=../img/screen_5.3f81.png alt=Help5></p><p>We now have to choose what we want to buy, lets go with potatoes since we are having chips tonight:</p><p><img src=../img/screen_6.03a8.png alt=Help6></p><p>Our item now appears in the to buy list, this is much like a shopping list of things we want to buy. Lets go ahead and buy this product within IOU. All we need to do is click on the item itself:</p><p><img src=../img/screen_7.1eb2.png alt=Help7></p><p>Ok, we can now add the price and press &#39;BUY&#39;:</p><p><img src=../img/screen_8.3d2b.png alt=Help8></p><p>Our product will now appear in the bought items list, along with its name, price, date bought and a picture of who bought it. Please note that the big gray number at the top of the page still reads &#39;£0.00&#39; despite the fact we have bought an item. That is because we are the only member of our list. If we, want to be the only member of this list and only use it to track personal expenses, we can leave it as it is, however, if we want to split the expenses with others, we have to add new members. Lets click on the members tab:</p><p><img src=../img/screen_9.abb3.png alt=Help9></p><p>To create add a new member, simply click on the &#39;NEW&#39; button at the bottom of the page. Please note that you will only be able to see a list of your Facebook friends that also happen to be members of the IOU app:</p><p><img src=../img/screen_10.4e0e.png alt=Help10></p><p>Lets choose one of our friends by clicking the &#39;ADD&#39; button. We can also cancel this action and filter the list, much like in the home page.</p><p><img src=../img/screen_11.a091.png alt=Help11></p><p>Ok, we are now £2.50 positive in our list, sometimes, we need to &#39;pull and refresh&#39; to ensure we have the latest calculation updated:</p><p><img src=../img/screen_12.8dbb.png alt=Help12></p><p>We can always go back to our products page if we want to add a new product or edit a product we bought in the past. Let&#39;s edit the product we bought by clicking it:</p><p><img src=../img/screen_13.22b4.png alt=Help13></p><p>We can change its name, price and who bought it. Lets go ahead and change the person who bought it by clicking our picture:</p><p><img src=../img/screen_14.a325.png alt=Help14></p><p>We can now only choose those who are members of our list:</p><p><img src=../img/screen_15.5fff.png alt=Help15></p><p>Ok, we have successfully reassigned who bought our first product, lets press ok to save the changes:</p><p><img src=../img/screen_16.4edb.png alt=Help16></p><p>Please note that we are now £2.50 in debt. We can always navigate back to the home page by pressing the &#39;HOME&#39; icon at the top left corner of the screen:</p><p><img src=../img/screen_17.4e78.png alt=Help17></p><p>Lists can be edited and deleted, those options can be revealed by swiping the list name from right to left:</p><p><img src=../img/screen_18.9618.png alt=Help18></p><p>A quick access menu is also available on all pages:</p><p><img src=../img/screen_19.b347.png alt=Help19></p><p>We hope you enjoy IOU as much as we do.</p></div><div class=breakpage><div class=breakpage>&nbsp;</div><h2>Appendix C - The included USB</h2><p>The included USB stick contains the source code for both the documentation and the application itself named implementation.</p><p>In order to create local builds and even make amendments, each section imposes a set of dependencies.</p><p>Appendix A explains in details how to compile and run the documentation files locally.</p><p>For the main IOU app, the following are the dependencies required for development:</p><ul><li>Git<ul><li>Git-flow</li></ul></li><li>Ruby and Ruby Gems<ul><li>SASS</li><li>Compass</li></ul></li><li>Node.js and NPM<ul><li>Grunt</li><li>Bower</li><li>Ionic</li><li>ios-sim (mac only)</li></ul></li><li>A UNIX based shell</li><li>SDKs<ul><li>Android SDK</li><li>iOS SDK (mac only, comes with XCode)</li></ul></li></ul><p>Below is a quick guide on how to build the IOU implementation:</p><p>1 - Either copy the content of the implementation directory or clone the repository directly from GitHub then &#39;cd&#39; into it:</p><div class=highlight><pre><code class=language-text data-lang=text>$ git clone https://github.com/jbonigomes/iou &amp;&amp; cd $_
</code></pre></div><p>2 - Install the npm dependencies:</p><div class=highlight><pre><code class=language-text data-lang=text>$ npm install
</code></pre></div><p>3 - Install the bower dependencies:</p><div class=highlight><pre><code class=language-text data-lang=text>$ bower install
</code></pre></div><p>4 - To view the app run:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt serve
</code></pre></div><p>5 - To build a new distribution run:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt build
</code></pre></div><p>6 - To serve a built app run:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt serve:dist
</code></pre></div><p>7 - To add a new platform run either/or:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt platform:add:ios
$ grunt platform:add:android
</code></pre></div><p>8 - To emulate a platform run:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt emulate:ios
</code></pre></div><p>9 - To build a new release:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt build:ios --release
</code></pre></div><p>Testing is still being implemented, however, the following command is already available for running unit tests:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt test
</code></pre></div><p>Should you wish to try the protractor tests, first install Protractor globally:</p><div class=highlight><pre><code class=language-text data-lang=text>$ npm install -g protractor
</code></pre></div><p>Update the webdriver:</p><div class=highlight><pre><code class=language-text data-lang=text>$ webdriver-manager update
</code></pre></div><p>Spin up the server:</p><div class=highlight><pre><code class=language-text data-lang=text>$ webdriver-manager start
</code></pre></div><p>You can now run end-to-end tests like so:</p><div class=highlight><pre><code class=language-text data-lang=text>$ protractor test/e2e/conf.js
</code></pre></div></div></body></html>