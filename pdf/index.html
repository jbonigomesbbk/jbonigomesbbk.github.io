<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>IOU</title><meta name=viewport content="width=device-width"><link rel=stylesheet href=../css/print.css></head><body><h1>Chapter 1</h1><h2>Introduction</h2><p>The idea for IOU came up from a need raised long before the current technology allowed its&#39; existence.</p><p>Being a foreigner living in London for over a decade, means that I had to share my house expenses with my housemates. This is not constrained to myself and my housemates, most of my friends also share their houses or flats. In fact this problem is not even constrained to a foreigner living in a different country, most students and young citizens also find it much easier to share their houses, easing down not only their expenses, but making friends and having due company in the process.</p><p>IOU is a simple application, that allows users to share and track their expenses with their Facebook friends, in fact, IOU has been designed so that one is not constrained to only use it for such purposes, one may wish to use it in order to track his own expenses, or who owes who in the last Barbecue party or even a family using it to know what groceries to buy.</p><p>The concept aims to be as simple as it can get, users create or are added to lists of products, each user can only view and edit lists that he/she belongs to. Each list has two sublists, a list of users and a list of products. The list of products is then subdivided into two lists, products that are due to be bought and products that have been already bought.</p><p>The sum of all products bought in a list, divided by the number of users, is the ideal amount each list member should had spent, however, in practice a member will rarely be in this situation, IOU will then label members as either a debtor or a creditor, if one is a debtor, he/she should be aware that is his/her turn to buy the next round of products.</p><p>A list lifecycle can last as long as it&#39;s members find suitable, when it is time to close the list, they may review how much each members owe each other, exchange money (which happens without any interference of IOU), then close the list.</p><p>For example, a list of expenses between two long term friends may never be closed and a list between housemates may be closed once one or more of the housemates decides to live somewhere else.</p><p>By no means IOU guarantees that the members who overspent money in a list will get paid back, it assumes that users have a &quot;Gentlemen&#39;s&quot; agreement among each other and should simply be used to track who&#39;s turn to buy products is and somewhat act as a reminder as to what should be bought.</p><p>At any given time, a user can open any given list and view who owes him/her and who he/she owes money to. This number should be optimised in terms of change, to avoid hassle in terms of money exchange, that is, if one is a creditor in a list, he/she should never need to pay anyone back, likewise, if one is a debtor, he/she should only pay back creditors their given percentage. This in turn should avoid users paying someone who will then use the money to pay someone else.</p><p>To make this all work, IOU is distributed as a mobile phone application and enforces users to login using their Facebook profiles. What makes IOU possible now is the fact that most of the population nowadays happen to own a Facebook account as well as a smartphone with access to the internet. This makes the application very convenient, enabling users to easily find their Friends and check what needs to be bought on the go.</p><h2>Notes about this documentation</h2><p>Code blocks appear as the following Scheme hello world example:</p><div class=highlight><pre><code class=language-text data-lang=text>(define hello-world
    (lambda ()
          (begin
         (write â€˜Hello-World)
             (newline)
         (hello-world))))
</code></pre></div><p>Code meant to be run in the terminal will be prefixed with a dollar &#39;$&#39; sign, please note that the &#39;$&#39; should not be typed in, as the following Grun initialise function demonstrates:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt init
</code></pre></div><p>Figures and captions are displayed like so:</p><p><img src=../img/sockets.b169.png alt=Fig1> <em>Fig 1 - Websockets architecture</em></p><h1>Chapter 2</h1><h2>Literature review and Context</h2><p>Although a good idea, IOU is not alone, in fact, there are several other smartphone applications that allow expense sharing and beyond, in this chapter I aim to rationalise each of the main alternatives and contrast where IOU exceeds and falls short.</p><p>The list of IOU phone apps comparison in this chapter is by no means exaustive, neither in number of features nor in the number of applications. It simply names the most popular applications available and analyses their main features.</p><h2>Splitwise</h2><h3>What is it</h3><p>A fully featured money spplitting application that allows users to track expenses and even caters for fairness common bill sharing problems such as, to which extent is a girlfriend a housemate and how rent should be split.</p><h3>Where it falls short</h3><p>Although it integrates with Google+, it has no integration with Facebook, making it a little harder to find your friends and rather difficult to use in different devices, having to remeber which email address and password was used when one first signed up for a service seems slightly out of fashion now.</p><p>For some, this may be a plus, but I find it has too many features, making it complicated to get started with, for example, when creating an item, the user has to stipulate how to split it, debts simplification is an option and it does not enforce the usage of groups.</p><p>It only tracks what users have spent, not what is due to be bought.</p><h3>Where it exceeds</h3><p>Other than the points made above, it is really hard to find something wrong with this application, it is available for all major platforms, including a web version, it is very complete, boasts a beautiful interface and is never wrong in when the subject comes to maths accuracy. Most of all, it is free.</p><p>If I were to choose an application other than IOU, Splitwise would be my first choice.</p><h2>I.O.U - I Owe You</h2><h3>What is it</h3><p>It is a simple application to keep track of IOU notes.</p><h3>Where it falls short</h3><p>It is only available for Android users and the interface is not particularly pleasant to look at. It does not integrate with social media of any kind operating more as a stand alone application.</p><h3>Where it exceeds</h3><p>Simplicity, it does what it says in the tin, tracks IOU notes.</p><h2>Still Waiting</h2><h3>What is it</h3><p>Yet another IOU reminder application.</p><h3>Where it falls short</h3><p>It does not integrate with Facebook and the app is not consistent through different platforms, the iOS version being much more superior both in terms of features and interface. The iOS version is not free of charge. Much like &#39;I.O.U - I Owe You&#39;, it is constrained to track IOU notes and not having a &#39;due to buy queue&#39;.</p><h3>Where it exceeds</h3><p>It has a pleasant interface and a pragmatic approach towards grouping bills based on people. Has a good set of options and even allows adding pictures and geolocation to your bills.</p><h2>IOU - by INEBAS</h2><h3>What is it</h3><p>An application for tracking expenses, bills and IOU notes.</p><h3>Where it falls short</h3><p>It is only available in the App Store and is not free of charge.</p><h3>Where it exceeds</h3><p>It has a beautiful and pleasant to use interface. Tracks lending and borrowing money.</p><h2>Conclusion</h2><p>In short, if one is looking for an IOU application, the options are endless, but what sets me into still wwant to create yet another IOU application is the fact that although all applications mentioned above (even those not mentioned), may do their job quite well, they fall short in the most fundamental issue, they do not solve my problem.</p><h3>The problem</h3><p>All applications tested and tried during the research time for IOU, I found that apps consistenly ignore the workflow of the user and simply focus on a more general approach to bill sharing, if they were to narrow their scope to a smaller niche, then they would be able to become the de facto app for that group.</p><p>The main feature that sets IOU apart from the others, is that fact that it allows users to set a desire to buy something, for example, if I am throwing a party, I may set up items to be bought, on a list, as my friends buy them, they mark the items as bought along with how much they spent, or, if I finish the milk at home, I may add it to my housemates list, perhaps another housemate will notice it before when strollilng in the supermarket before going home. IOU is not only a maths tool, but also, a communication tool.</p><h3>How does IOU approach it</h3><p>The way I envision IOU usage is by being an app that is checked every time one goes to the supermarket or remebers something to be bought for the weekend party or drinks the last bit of milk from the fridge. Once it becomes a habit to use it you no longer need to make groceries lists or ask anyone what is missing for the party or for the house in general.</p><p>In addition, IOU&#39;s datafeed happens real time, being always connected via a web socket, this means users do not need to trigger a page refresh, when the data changes, your screen changes too.</p><p>Finally, having Facebook integration, allows users to simply refer to IOU as an extension of an application they are already using. Making the eco system simple and familiar.</p><h3>Some aid literature</h3><ul><li><p>AngularJs from Novice to Ninja, by Sandeep Panda, is the single book that has helped me the most getting started in the world of Angular.js, explaining in a simple and effective way the various components that compose the eco-system.</p></li><li><p>Mastering Web Application Development with AngularJS, by Pawel Kozlowski and Peter Bacon Darwin proposes a by feature approach to structuring Angular.js apps, this is gradually becoming the de facto structure for most Angular.js applications.</p></li><li><p>Hackers and Painters, by Paul Graham, although not directly related to the work done towards IOU, when feeling overwhelmed by a technology or exhausted to the point of giving up, reading about Paul&#39;s experiences at ViaWeb uplifted my motivation and placed me back in the right track.</p></li><li><p>Both the Ionic and the Firebase blog have been essential in this journey too.</p></li></ul><h1>Chapter 3</h1><h2>Research/Development Method</h2><p>Chapter two described the problem domain, this chapter explains the rationale behing the technological decisions taken in order to achieve the best results in the implementation of IOU.</p><h3>The functional requirements</h3><p>IOU is mostly an online application, user data gets saved in the server and devices being used to access the data should be ubiquitous, that is, accessible from both a native mobile applicatoin or from a web appliation running on a browser.</p><p>The application should only allow login and registration via Facebook and the presence of websockets is a big plus, so that users do not need to refresh their views in order to see the most up-to-date information, much like a chat room.</p><p>Users should be able to create an unlimited amount of lists, on which they can add both members and products. Each list will also have a name and an icon associated to them. Both of which are editable. A list can only be viewed, edited or closed by their members.</p><p>Once a product is added to a list, it should be treated as an item that is still due to be bought. Any user from any given list can &#39;buy&#39; those products. Adding or editing the price and name of any product, both bought and due to be bought, can be done at any time. There should be a timestamp for each bought product that has been edited, staing the last time it was edited, any bought product that has been edited should display this timestamp.</p><p>Every list should also have a members view, where more members can be added and it should clearly state the breakdown of how much each member owes or is owed in relation to the user currently logged in.</p><p>The main list view should display the current user overall balance, that is, taking into account all lists he/she belongs to. Within the single list views, the overall balanced presented should be constrained to the current list.</p><p>The Login page, Terms and conditions of usage an Privacy Policy pages should be open to the public, however, all other pages should be private.</p><p>A left navigation menu should be present on all private pages, showing the picture and name of who is logged in as well as links to the home view, the terms and conditions view, the privacy policy view and a logout feature, that should clear all local storage data, logout the user and redirect to the login page.</p><p>A go home button should be present on all screens to aid navigation.</p><p>The main action of each page should be presented in a block button in the bottom of each page.</p><h3>The backend technology choices</h3><p>There is no doubt that to achieve it, data should be provided by means of a Web Service Restful API, where the endpoints expose data in a convinient JSON format to be consumed by either a native moblie application or from a web application running on a browser. However, the options on how to implent such structure are endless. Below is a list of the choices and the rationale behind them:</p><ul><li><p>PHP backend using Laravel:</p><ul><li>Pros: This would&#39;ve been the easiest solution, Laravel is a very flexible framework that provides powerful and yet simple to use features. It&#39;s routing system could easily cater for the nescessities of IOU, queues are easy to integrate and packages such as socialite can take care of the Facebook authentication.</li><li>Cons: Although there is a possibility to use other databases, MySQL is still the predominant option within the PHP world. Websockets are rather difficult to integrate. Even though HHVM can compile PHP code to C, it still lacks the extra speed boost nescessary for a real time app.</li></ul></li><li><p>Node.js:</p><ul><li>Pros: Works really well with noSQL databases and websockets. Frameworks like Sails make it really easy to create and expose a Restful API and it performs quite well in terms of speed.</li><li>Cons: Not as easy as with PHP to find a suitable free server to start the work.</li></ul></li><li><p>Firebase:</p><ul><li>Pros: No need to write an API, store your data on Firebase, set up your security rules and you are ready to go. Full support for websockets and Facebook integration. Fast speed from noSQL databases and the entry plan is free of charge.</li><li>Cons: If you want to process anything other than data, such as images and payment, you will still need a backend system other than Firebase. As your application expands plans become more expensive.</li></ul></li></ul><h3>The frontend technology choices</h3><p>For the frontend app, the choices were more limited, that is, in order to run a native application on a phone, one must develop constrained to the architecture he/she is writting if for. For example, Java is the native environment for Android apps and iOS developers have a choice between Swift and Objective-C.</p><p>Another option was to create a hybrid phone application, that is, write it using common web application technologies such as HTML, CSS and JavaScript, then compile it using either PhoneGap or Apache Cordova to run in an in-app browser. As a side note, PhoneGap is a branch from the open source project Apache Cordova administered by Adobe.</p><p>The last option was to use Titanium AppCelerator, which sits somewhere in between a native and a hybrid application, Titanium exposes a JavaScript API and converts them to the native function calls to the target architecture on compiling time.</p><p>Despite having to choose which is frontend technology is best suited for IOU, one more element had to be considered. That is, the addition of a framework that would allow faster development and provide amenites such as high level abstractions for the platform and testing facilities. This is specially important, since the app has to run on more than one platform, including web.</p><p>At this point, the idea of using either a native application solution or Titanium, were begining to fade, native apps would be constrained to one architecture only and therefore, have to be re-developed for every other platform I would want to have it deployed to. Titanium, solves that problem, but falls short if you want to deploy your app to the web. Not to mention a rather cryptic API.</p><p>That&#39;s when I came across Ionic, Ionic is a frontend SDK for developing hybrid mobile apps. Framewoks such as Lungo and Topcoat, do cover part of what Ionic does, that is, they provide consistent widgets that can be used interchangeably throughout different platforms. However, Ionic goes the extra mile, not only providing frontend widgets, but also exposing and API that wraps Apache Cordova and a tight integration with Angular.js, making it the ultimate production tool when the subject comes to developing hybrid phone applications.</p><h3>The decisions</h3><p>The final choice was to stick to Ionic for the frontend and Firebase for the backend.</p><p>The main rationale behind this decision was how both technologies combine and complement each other. Firebase provides a driver that integrates with Angular.js, converting it into a true 3-way data binding tool.</p><p>Angular.js is a tool backed up by Google which aims to structure JavaScript apps and impulse the development of applications that otherwise would be impossible to develop or to the very least take too long.</p><p>Besides, Angular&#39;s Eco System boasts a vibrant community, integration with Node.js workflow tools such as yeoman, bower and grunt are a breeze, E2E and Unit testing tools options are vast and Directives trully extend the vocabulary of HTML.</p><p>It still falls short in a sense that the application is not native, that is, some of the transition effects may not be as smooth as those provided natively and despite Firebase being a really interesting backend solution, in future, if the app needs to consume more powerfull features, such as image resize and integration with a payment gateway, Firebase will not sufice.</p><p>Nevertheless, the combination of those tools have been proven to be right for IOU, future improvements will dictate what other technologies will be used.</p><p>The diagram below represents the communication between the clients and the server. Every request that goes to Firebase must first satisfy the security rules. The double arrows represent the websockets:</p><p><img src=../img/sockets.b169.png alt=Fig1> <em>Fig 1 - Websockets architecture</em></p><h2>The workflow</h2><p>Now that the technologies have been chosen, an efficient workflow must be devised in order to maximize production and generate good quality builds. Below is a detailed list of the main technologies used for this application:</p><ul><li>Git<ul><li>Git-Flow</li></ul></li><li>Node.js<ul><li>lodash</li><li>mocha</li><li>corodova</li><li>chai</li><li>Yeoman</li><li>generator-ionic</li><li>Bower</li><li>Angular.js</li><li>Ionic</li><li>Firebase</li><li>Angular Fire</li><li>Firebase Simple Login</li><li>Angular Local Storage</li><li>Grunt</li><li>load-grunt-tasks</li><li>time-grunt</li><li>autoprefixer</li><li>bower-install</li><li>concurrent</li><li>contrib-clear</li><li>contrib-compass</li><li>contrib-concat</li><li>contrib-connect</li><li>contrib-copy</li><li>contrib-cssmin</li><li>contrib-htmlmin</li><li>contrib-jshint</li><li>contrib-uglify</li><li>contrib-watch</li><li>karma</li><li>newer</li><li>ngmin</li><li>usemin</li><li>stylish</li><li>Karma</li><li>karma-chai</li><li>karma-chrome-chai</li><li>karma-coverage</li><li>karma-mocha</li><li>karma-phantomjs-launcher</li></ul></li><li>Ruby Gems<ul><li>SASS</li><li>Compass</li></ul></li><li>Android SDK</li><li>iOS SDK</li></ul><p>In addition, the cordova inappbrowser plugin has also been installed to aid allow Facebook login with Firebase.</p><h1>Chapter 4</h1><h2>Data/Findings/Designs</h2><p>the project outcome. This might be data collected and tabulated or the design of a program, or whatever outcome was obtained.</p><p>Links for the application and the application home page and web version and github</p><h3>Information diagram</h3><h3>Designs</h3><h1>Chapter 5</h1><h2>Analisys/Evaluation/Testing</h2><p>assessing or testing the project outcome. If the project is of type 3 or 4 then any computer code shold be tested using range inputs.</p><p>Look into all angular js testing frameworks, Karma, Protractor and Jasmine.</p><h1>Chapter 6</h1><h2>Conclusion/Recommendations</h2><p>as a result of the project. The project does not need to have a positive conclusion. For example, it might prove that some system was not successful. You should indicate to what extent your objectives have been achieved.</p><ul><li>add different currencies</li><li>add a users guide/help page</li><li>create an explanation video</li><li>allow ordering of items (lists and products)</li><li>compile the app for Blackberry and windows phone</li><li>allow archiving lists</li><li>create invite friends feature</li><li>allow removing items from list</li><li>allow removing user from list if he/she did not buy anything yet</li><li>send welcome email when user registers</li><li>have a loading icon when pages are being loaded</li><li>create a splash screen</li><li>improve overall look an feel</li><li>get an approval from Facebook to view a complete list of all friends for any user</li></ul><h1>Chapter 7</h1><h2>Review/Reflections</h2><p>reflect about usage of noSQL and how hard it was to make a transition between the relational world to Firebase.</p><p>the original structure:</p><div class=highlight><pre><code class=language-text data-lang=text>{
  &quot;logs&quot; : {
    &quot;123&quot; : {
      &quot;bought&quot; : {
        &quot;567&quot; : {
          &quot;amended&quot; : true,
          &quot;date&quot; : 1412635438623,
          &quot;name&quot; : &quot;October&quot;,
          &quot;owner&quot; : &quot;10152357995965379&quot;,
          &quot;price&quot; : &quot;28&quot;
        },
        &quot;891&quot; : {
          &quot;amended&quot; : false,
          &quot;date&quot; : 1416851097157,
          &quot;name&quot; : &quot;Top up&quot;,
          &quot;owner&quot; : &quot;10152774088530030&quot;,
          &quot;price&quot; : &quot;30.00&quot;
        }
      },
      &quot;image&quot; : &quot;lightbulb&quot;,
      &quot;members&quot; : {
        &quot;444&quot; : true,
        &quot;555&quot; : true
      },
      &quot;name&quot; : &quot;Electricity&quot;
    },
    &quot;234&quot; : {
      &quot;bought&quot; : {
        &quot;912&quot; : {
          &quot;amended&quot; : false,
          &quot;date&quot; : 1412635323357,
          &quot;name&quot; : &quot;Salt&quot;,
          &quot;owner&quot; : &quot;10201952652612125&quot;,
          &quot;price&quot; : &quot;0.29&quot;
        },
        &quot;111&quot; : {
          &quot;amended&quot; : true,
          &quot;date&quot; : 1415408705349,
          &quot;name&quot; : &quot;Kitchen roll X2&quot;,
          &quot;owner&quot; : &quot;10152774088530030&quot;,
          &quot;price&quot; : &quot;3.29&quot;
        },
      },
      &quot;image&quot; : &quot;hazard&quot;,
      &quot;members&quot; : {
        &quot;444&quot; : true,
        &quot;555&quot; : true
      },
      &quot;name&quot; : &quot;Household&quot;
    }
  },
  &quot;users&quot; : {
    &quot;444&quot; : {
      &quot;.priority&quot; : &quot;444&quot;,
      &quot;currency&quot; : &quot;Â£&quot;,
      &quot;name&quot; : &quot;Jose Gomes&quot;
    },
    &quot;555&quot; : {
      &quot;.priority&quot; : &quot;555&quot;,
      &quot;currency&quot; : &quot;Â£&quot;,
      &quot;name&quot; : &quot;Nik Grinkevich&quot;
    },
  }
}
</code></pre></div><p>The final structure:</p><div class=highlight><pre><code class=language-text data-lang=text>{
  // rooms contains only meta info about each room
  // stored under the room&#39;s unique ID
  &quot;rooms&quot;: {
    &quot;one&quot;: {
      &quot;name&quot;: &quot;room alpha&quot;,
      &quot;type&quot;: &quot;private&quot;
    },
    &quot;two&quot;: { ... },
    &quot;three&quot;: { ... }
  },

  // room members are easily accessible (or restricted)
  // we also store these by room ID
  &quot;members&quot;: {
    // we&#39;ll talk about indices like this below
    &quot;one&quot;: {
      &quot;mchen&quot;: true,
      &quot;hmadi&quot;: true
    },
    &quot;two&quot;: { ... },
    &quot;three&quot;: { ... }
  },

  // messages are separate from data we may want to iterate quickly
  // but still easily paginated and queried, and organized by room ID
  &quot;messages&quot;: {
    &quot;one&quot;: {
      &quot;m1&quot;: { &quot;sender&quot;: &quot;mchen&quot;, &quot;message&quot;: &quot;foo&quot; },
      &quot;m2&quot;: { ... },
      &quot;m3&quot;: { ... }
    },
    &quot;two&quot;: { ... },
    &quot;three&quot;: { ... }
  }
}
</code></pre></div><p>now the security rules can be written like this</p><div class=highlight><pre><code class=language-text data-lang=text>...
</code></pre></div><p>Reflect about the facebook oAuth...</p><h1>Chapter 8</h1><h2>References</h2><h1>Chapter 9</h1><h2>Bibliography</h2><h1>Chapter 10</h1><h2>Appendix - About this documentation</h2><h3>The dilemma</h3><p>At the time of this writing, I faced a dilemma, which word processor is the best processor for writing this documentation.</p><p>The most obvious choices were:</p><ul><li>Microsoft Word</li><li>Apple Pages</li><li>Google Docs</li></ul><p>Surely any of the choices above would be suitable, however, in my humble opinion, such options can be somewhat &#39;evil&#39; when it comes to document formatting, turning most documentation written in one platform unreadable in the other or to the very least almost certainly not looking as intended.</p><p>In general, converting the document to a PDF format remediates this problem, however, I am now left with the fact that my content is tightly coupled to the editor that created the documentation. Modification is difficult, for example, someone else may wish to edit the document, or perhaps if at some point in time in the near future I decide to present my documentation as an HTML document on the web, or perhaps as a deck of slides or even publish it in a book format, I may have to revise the entire text looking for any &#39;evil&#39; formatting issues that was not visible in the former format.</p><p>Finally, as a writer, when writing documentation, I should concentrate on writing the documentation, and not about auto generated formatting issues that may arise and drag productivity in a typical writing session. The writer should only worry about the semantics and the content of his/her writing, formatting should be done separately, perhaps not even by the writer himself, or better, simply choose a new format from predefined options written by a talented designer.</p><p>LaTeX is a really good option to move away from the formatting problems mentioned above, and beyond, however, it does trap the writer with a little clutter to tinker with in terms of settings and so on. What I am trying to say is, once the document is finalised, it no longer consists of the content and the content only, but also carries several formatting tags. This is one hand demonstrates how powerful LaTeX can be, but in the other, may confuse and distract the writer.</p><h3>The solution</h3><p>Since this course is about computer science, I set off to find a solution that would allow me and any other developer to run away from the masses and write simple interchangeable documentation with ease. Writing a solution that could potentially be further enhanced to the point a non programmer could also benefit from.</p><p>The requirements were:</p><ul><li>Write content and content only, without distractions</li><li>Formatting should be written separately and be interchangeable/themeable<ul><li>This also means that if some time in future I want to publish my content to a different media, I should be able to do so without too much effort</li></ul></li><li>It should not be coupled to any specific text editor</li><li>It should have an automated building and deployment solution</li></ul><p>The answer was always there, Markdown. Markdown is a really simple and easy to use markup language, it is the de facto standard for readme files in software development and widely used in blogs throughout the web.</p><p>A short introduction to Markdown syntax can be found in the link below:</p><p><a href=http://daringfireball.net/projects/Markdown/syntax>http://daringfireball.net/projects/Markdown/syntax</a></p><p>Although Markdown may not be as powerful as LaTeX, the community around it is immense and really keen in providing further enhancements to it, the following link lists many projects and plugins that address some of those short-comes:</p><p><a href=https://github.com/cben/mathdown/wiki/math-in-Markdown>https://github.com/cben/mathdown/wiki/math-in-Markdown</a></p><p>The community also provides an excellent open source Markdown editor called Mou, although Mac specific, all other major operating systems have free alternatives to Mou:</p><p><a href="http://25.io/mou/">http://25.io/mou/</a></p><p>Finally, there is an open source project which is now maintained by Jakob Truelsen and Ashish Kulkarni, called wkhtmltopdf, this headless command line tool, allows any HTML document to be converted to PDF, and since Markdown is easily convertible to HTML, we now have all the tools we need in order to create our documentation.</p><p><a href="http://wkhtmltopdf.org/">http://wkhtmltopdf.org/</a></p><h3>The workflow</h3><p>To make this work, we will need to automate every step of the process, so that we can only write Markdown, then compile/deploy our work with only one command and in the process, if we wish to do so, add some personalised styles to our document.</p><p>The application that holds the documentation has been scaffolded using Yeoman, more specifically, using a generator called generator-jekyllrb.</p><p><a href=https://github.com/robwierzbowski/generator-jekyllrb>https://github.com/robwierzbowski/generator-jekyllrb</a></p><p>Although Yeoman is an NPM package, backed by Node.js, it combines three simple but powerful Ruby Gems:</p><ul><li>Jekyll: A static blog generator created by the GitHub Team. It provides an easy to use templating language called Liquid as well as giving the means to transform Markdown files into HTML, finally compiling the entire application into deployable static websites.</li><li>Redcarpet: A Markdown to HTML converter.</li><li>Compass: A CSS pre-processor extension of SASS.</li></ul><p>Moreover, Jekyll makes it really easy to deploy and host your application directly on Github free of charge.</p><p>This Yeoman generator also leverages the power of Grunt and Bower into the workflow.</p><p>Most of the Grunt tasks used for this documentation have also been used for the main IOU application, however, a few notable differences are mentioned below:</p><ul><li>grunt-build-control: Allows deployment to Github via Git.</li><li>grunt-jekyll: integrates Jekyll with Node.js.</li><li>grunt-wkhtmltopdf: Compiles HTML files to PDF.</li></ul><h3>Developing locally</h3><p>If you wish to use this workflow for other projects or simply try out what has been created so far, please follow the following instructions and make sure all dependencies are met and available on your path:</p><p>Dependencies:</p><ul><li>Git</li><li>Ruby and Ruby Gems<ul><li>SASS</li><li>Compass</li><li>Jekyll</li></ul></li><li>Node.js and NPM<ul><li>Grunt</li><li>Bower</li></ul></li><li>wkhtmltopdf</li></ul><p>Git clone this repository and <code>cd</code> into it:</p><div class=highlight><pre><code class=language-text data-lang=text>$ git clone https://github.com/jbonigomesbbk/jbonigomesbbk.github.io &amp;&amp; cd $_
</code></pre></div><p>Install the NPM packages:</p><div class=highlight><pre><code class=language-text data-lang=text>$ npm install
</code></pre></div><p>Install the Bower dependencies:</p><div class=highlight><pre><code class=language-text data-lang=text>$ bower install
</code></pre></div><p>Serve the app:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt serve
</code></pre></div><p>Other than <code>serve</code>, you may wish to run:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt serve:dist
</code></pre></div><p>The latter will first build the application then serve the optimised code, the former, may be a better option when debugging as files will not be minified and changes will be automatically refresh in the browser using &#39;browser sync&#39;.</p><p>Once displayed in the brower, you may wish to explore the documentation and view the PDF generated version too, link found right below the left navigation bar.</p><p>The directory structure will look as follow:</p><ul><li>.jekyll</li><li>.sass-cache</li><li>.tmp</li><li>app</li><li>dist</li><li>node_modules</li></ul><p>And the root directory hold the following files:</p><ul><li>.bowerrc</li><li>.csslintrc</li><li>.editorconfig</li><li>.gitattributes</li><li>.gitignore</li><li>.jshintrc</li><li>_config.build.yml</li><li>_config.yml</li><li>bower.json</li><li>Gemfile</li><li>Gruntfile.js</li><li>package.json</li></ul><p>The top most directories, prefixed with a dot &#39;.&#39; only hold temporary files required by Jekyll to serve the application locally.</p><p>All files in the root directory are common configuration files for Git, Jekyll and Node.js.</p><p>The node_modules directory holds all the Grunt tasks.</p><p>The app directory is where we, developers will actually work.</p><p>The dist directory holds the last build from our application, that is, the result of our code. For every build, Grunt will delete this directory and re-create it based on our changes. The dist directory holds the optimised code that is ready for production.</p><p>The app directory tree structure looks like this:</p><ul><li>_bower components</li><li>_includes</li><li>_layouts</li><li>_posts</li><li>_scss</li><li>docs</li><li>fonts</li><li>img</li><li>js</li><li>pdf</li></ul><p>The top most directory <code>_bower_components</code> holds the Bower dependencies. All the directories prefixed with an underscore &#39;_&#39; will not be coppied to the dist directory during the build process.</p><ul><li>_includes: holds the cover page and the xsl file used to generate the table of contents in the PDF.</li><li>_layouts: hold the layout for the main web page, the layout for the documentation page and the layout for the PDF file.</li><li>_posts: holds the actual Markdown that makes up this documentation, they have been separated by chapters.</li><li>_scss: the SASS styles for the app and the print.scss, used by the PDF file.</li><li>docs: holds the documentation landing page.</li><li>fonts: the web fonts used in this project.</li><li>img: the images.</li><li>js: the JavaScript.</li><li>pdf: a placeholder HTML file containing all chapters and extending the PDF layout, as well as the actual generated PDF file.</li></ul><p>During your workflow, you may notice that the PDF file looks well formated when running <code>grunt serve:dist</code> however, this statement does not hold true when running <code>grunt serve</code>, this is because Jekyll compiles the temporary CSS file in a different location when running on debug mode, to avoid too much overhead, when testing the PDF&#39;s layout you may use this short-hand:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt build
</code></pre></div><p>This will build the latest changes and save them under the dist directory, including a well formatted PDF file. You may now open the PDF directly:</p><div class=highlight><pre><code class=language-text data-lang=text>$ open dist/pdf/index.pdf
</code></pre></div><p>If you wish to deploy this app to GitHub, you will need to update the remote option in the buildcontrol task, found in the Gruntfile.js, swap it with a valid GitHub Page repository path, more details about GitHub Pages, Jekyll and BuildControl can be found in the link below:</p><ul><li><a href="https://pages.github.com/">https://pages.github.com/</a></li><li><a href="http://jekyllrb.com/">http://jekyllrb.com/</a></li><li><a href=https://github.com/robwierzbowski/grunt-build-control>https://github.com/robwierzbowski/grunt-build-control</a></li></ul><p>Once set up, you may deploy your code using:</p><div class=highlight><pre><code class=language-text data-lang=text>$ grunt deploy
</code></pre></div><h3>Roadmap</h3><ul><li>Keep improving this workflow and gathering feedback from others on how to improve it.</li><li>Create a more generic version to use as a starting point for future documentations, perhaps a Yeoman generator.</li><li>Fix the issue with no styles in the PDF&#39;s generated with <code>grunt serve</code>.</li><li>Create new themes for the Markdown&#39;s, so far it is using the generic GitHub flavour styles.</li></ul><h3>Details</h3><p>The source code for this documentation can be found at:</p><p><a href=https://github.com/jbonigomesbbk/jbonigomesbbk.github.io>https://github.com/jbonigomesbbk/jbonigomesbbk.github.io</a></p><p>The latest build of this documentation can be found here:</p><p><a href=http://jbonigomesbbk.github.io/docs>http://jbonigomesbbk.github.io/docs</a></p></body></html>